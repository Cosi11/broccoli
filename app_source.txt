===================
ROULETTE APP SOURCE
===================


==========================================
FILE: app/build.gradle.kts
==========================================

plugins {
    id("com.android.application")
    id("org.jetbrains.kotlin.android")
    id("com.google.devtools.ksp")
    id("com.google.dagger.hilt.android")
    id("androidx.navigation.safeargs.kotlin")
    kotlin("kapt")
}

buildscript {
    dependencies {
        classpath("com.google.devtools.ksp:com.google.devtools.ksp.gradle.plugin:${Versions.ksp}")
    }
}

android {
    namespace = "com.roulette.tracker"
    compileSdk = Versions.compileSdk
    buildToolsVersion = Versions.buildToolsVersion

    defaultConfig {
        applicationId = "com.roulette.tracker"
        minSdk = Versions.minSdk
        targetSdk = Versions.targetSdk
        versionCode = 1
        versionName = "1.0"

        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
        
        ndk {
            abiFilters += listOf("armeabi-v7a", "arm64-v8a", "x86", "x86_64")
        }

        ndkVersion = "26.1.10909125"
    }

    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
        isCoreLibraryDesugaringEnabled = true
    }

    kotlinOptions {
        jvmTarget = "17"
        freeCompilerArgs += listOf("-Xjvm-default=all")
    }

    buildFeatures {
        viewBinding = true
        dataBinding = true
        compose = true
    }

    composeOptions {
        kotlinCompilerExtensionVersion = Versions.composeCompiler
    }

    ksp {
        arg("dagger.fastInit", "true")
        arg("room.schemaLocation", "$projectDir/schemas")
    }

    kapt {
        correctErrorTypes = true
        arguments {
            arg("dagger.fastInit", "true")
        }
    }

    sourceSets {
        getByName("main") {
            java.srcDirs("src/main/kotlin", "src/main/java")
        }
        getByName("test") {
            java.srcDirs("src/test/kotlin", "src/test/java")
        }
        getByName("androidTest") {
            java.srcDirs("src/androidTest/kotlin", "src/androidTest/java")
        }
    }

    configurations.all {
        resolutionStrategy {
            exclude(group = "org.tensorflow.lite.support", module = "litert-support-api")
        }
    }
    
    lint {
        warning += "DuplicateNamespace"
    }
}

dependencies {
    // AndroidX Core
    implementation(Deps.AndroidX.core)
    implementation(Deps.AndroidX.appCompat)
    
    // Material Design
    implementation(Deps.UI.material)
    
    // Lifecycle
    implementation(Deps.AndroidX.Lifecycle.runtime)
    implementation(Deps.AndroidX.Lifecycle.viewModel)
    
    // Hilt
    implementation("com.google.dagger:hilt-android:${Versions.hilt}")
    kapt("com.google.dagger:hilt-android-compiler:${Versions.hilt}")
    
    // Hilt Extensions
    implementation("androidx.hilt:hilt-work:${Versions.hiltWork}")
    implementation("androidx.hilt:hilt-navigation-compose:${Versions.hiltNavigationCompose}")
    kapt("androidx.hilt:hilt-compiler:${Versions.hiltWork}")
    
    // Worker
    implementation("androidx.work:work-runtime-ktx:2.9.0")
    
    // Coroutines fÃ¼r Worker
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:${Versions.coroutines}")
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:${Versions.coroutines}")
    
    // Navigation
    implementation(Deps.Navigation.fragment)
    implementation(Deps.Navigation.ui)
    
    // CameraX
    implementation(Deps.AndroidX.Camera.core)
    implementation(Deps.AndroidX.Camera.camera2)
    implementation(Deps.AndroidX.Camera.lifecycle)
    implementation(Deps.AndroidX.Camera.view)
    
    // Room
    implementation("androidx.room:room-runtime:2.6.1")
    implementation("androidx.room:room-ktx:2.6.1")
    ksp("androidx.room:room-compiler:2.6.1")
    
    // TensorFlow
    implementation("org.tensorflow:tensorflow-lite:2.17.0")
    implementation("org.tensorflow:tensorflow-lite-support:0.5.0")
    
    // OCR - Verwende die lokale Tesseract-Bibliothek oder eine alternative OCR-LÃ¶sung
    // TemporÃ¤r auskommentiert bis wir eine Alternative haben
    // implementation("com.github.adaptech-cz.Tesseract4Android:tesseract4android:4.8.0")
    
    // Tests
    testImplementation(Deps.Test.junit)
    androidTestImplementation(Deps.Test.androidxJunit)
    androidTestImplementation(Deps.Test.espresso)

    kspTest(Deps.Hilt.compiler)
    kspAndroidTest(Deps.Hilt.compiler)

    coreLibraryDesugaring(Deps.Tools.desugar)

    // Kotlin
    implementation(Deps.Kotlin.bom)
    implementation(Deps.Kotlin.stdlib)
    implementation(Deps.Kotlin.coroutinesAndroid)
    implementation(Deps.Kotlin.coroutinesCore)

    // OpenCV - Verwenden Sie das lokale Modul
    implementation(project(":opencv"))

    // Compose Dependencies
    implementation(platform("androidx.compose:compose-bom:${Versions.composeBom}"))
    androidTestImplementation(platform("androidx.compose:compose-bom:${Versions.composeBom}"))

    implementation("androidx.compose.ui:ui")
    implementation("androidx.compose.material3:material3")
    implementation("androidx.compose.ui:ui-tooling-preview")
    debugImplementation("androidx.compose.ui:ui-tooling")
    debugImplementation("androidx.compose.ui:ui-test-manifest")

    // Stelle sicher, dass die Kotlin-Version korrekt ist
    implementation(platform("org.jetbrains.kotlin:kotlin-bom:${Versions.kotlin}"))
} 

==========================================
FILE: opencv-wrapper/build.gradle.kts
==========================================

plugins {
    id("com.android.library")
    kotlin("android")
}

android {
    namespace = "com.roulette.tracker.opencv"
    compileSdk = Versions.compileSdk

    defaultConfig {
        minSdk = Versions.minSdk
        
        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
        consumerProguardFiles("consumer-rules.pro")
    }

    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }
    
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }

    kotlinOptions {
        jvmTarget = "17"
    }

    sourceSets.getByName("main").apply {
        java.srcDirs("src/main/java")
    }
}

dependencies {
    api(project(":opencv"))
    
    // AndroidX Core
    implementation("androidx.core:core-ktx:1.12.0")
    implementation("androidx.appcompat:appcompat:1.6.1")
    
    // Test dependencies
    testImplementation("junit:junit:4.13.2")
    androidTestImplementation("androidx.test.ext:junit:1.1.5")
} 

==========================================
FILE: opencv/build.gradle.kts
==========================================

plugins {
    id("com.android.library")
    id("org.jetbrains.kotlin.android")
}

android {
    namespace = "org.opencv"
    compileSdk = Versions.compileSdk

    defaultConfig {
        minSdk = Versions.minSdk
        
        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
        consumerProguardFiles("consumer-rules.pro")
    }

    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }
    
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }

    kotlinOptions {
        jvmTarget = "17"
    }

    sourceSets {
        getByName("main") {
            java.srcDirs("src/main/java")
            aidl.srcDirs("src/main/aidl")
            manifest.srcFile("src/main/AndroidManifest.xml")
            jniLibs.srcDirs("src/main/jniLibs")
            res.srcDir("src/main/res")
        }
    }

    buildFeatures {
        buildConfig = true
        aidl = true
    }

    externalNativeBuild {
        cmake {
            path = file("src/main/cpp/CMakeLists.txt")
        }
    }
    
    ndkVersion = "25.2.9519653"

    lint {
        abortOnError = false
        checkReleaseBuilds = false
    }

    tasks.withType<com.android.build.gradle.tasks.AidlCompile>().configureEach {
        outputs.dir(layout.buildDirectory.dir("generated/aidl_source_output_dir/${this.name}"))
    }
}

tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile>().configureEach {
    kotlinOptions {
        jvmTarget = "17"
    }
}

tasks.withType<JavaCompile>().configureEach {
    options.compilerArgs.addAll(listOf(
        "-Xlint:-options",
        "-Xmaxerrs", "500"
    ))
    options.encoding = "UTF-8"
}

tasks.withType<JavaCompile>().configureEach {
    exclude("**/examples/**", "**/samples/**")
}

tasks.withType<JavaCompile>().configureEach {
    doFirst {
        val aidlDir = project.buildDir.resolve("generated/aidl_source_output_dir")
        if (aidlDir.exists()) {
            aidlDir.walk().filter { it.isFile && it.extension == "java" }.forEach { file ->
                val content = file.readText()
                val cleaned = content.replace("\\", "/")
                file.writeText(cleaned)
            }
        }
    }
}

dependencies {
    implementation("androidx.annotation:annotation:1.7.1")
    implementation(Deps.AndroidX.core)
    implementation(Deps.AndroidX.appCompat)
    testImplementation(Deps.Test.junit)
    androidTestImplementation(Deps.Test.androidxJunit)
    androidTestImplementation(Deps.Test.espresso)
} 

==========================================
FILE: buildSrc/build.gradle.kts
==========================================

plugins {
    `kotlin-dsl`
}

repositories {
    google()
    mavenCentral()
}

buildscript {
    repositories {
        google()
        mavenCentral()
    }
}

dependencies {
    implementation("org.jetbrains.kotlin:kotlin-gradle-plugin:1.9.22")
    implementation("com.android.tools.build:gradle:8.8.1")
}

kotlin {
    jvmToolchain(17)
}

configurations.all {
    resolutionStrategy {
        cacheChangingModulesFor(0, "seconds")
        cacheDynamicVersionsFor(0, "seconds")
        force("org.jetbrains.kotlin:kotlin-stdlib:1.9.22")
        force("org.jetbrains.kotlin:kotlin-reflect:1.9.22")
    }
} 

==========================================
FILE: buildSrc/src/main/kotlin/Dependencies.kt
==========================================

object Versions {
    const val kotlin = "1.9.22"
    const val hilt = "2.55"
    const val hiltWork = "1.1.0"
    const val hiltNavigationCompose = "1.1.0"
    const val compileSdk = 35
    const val minSdk = 26
    const val targetSdk = 35
    
    const val ksp = "1.9.22-1.0.17"
    
    const val navigation = "2.7.6"
    
    // Korrekte Versionen fÃ¼r SDK 34
    const val androidxCore = "1.12.0"
    const val androidxAppCompat = "1.6.1"
    const val material = "1.11.0"
    const val lifecycleRuntime = "2.7.0"
    const val lifecycleViewModel = "2.7.0"
    const val cameraX = "1.4.1"
    const val hiltCompiler = "1.1.0"
    const val room = "2.6.1"
    const val tensorflow = "2.14.0"
    const val tensorflowSupport = "0.4.4"
    const val junit = "4.13.2"
    const val androidxJunit = "1.2.1"
    const val espresso = "3.6.1"
    const val desugar = "2.1.4"
    const val kotlinStdlib = "1.9.22"
    const val coroutines = "1.7.3"
    
    const val buildToolsVersion = "35.0.0"
    const val agp = "8.8.1"
    const val gradle = "8.10.2"
    
    const val composeCompiler = "1.5.8"
    const val composeBom = "2024.02.00"
}

object Deps {
    object AndroidX {
        const val core = "androidx.core:core-ktx:${Versions.androidxCore}"
        const val appCompat = "androidx.appcompat:appcompat:${Versions.androidxAppCompat}"
        
        object Lifecycle {
            const val runtime = "androidx.lifecycle:lifecycle-runtime-ktx:${Versions.lifecycleRuntime}"
            const val viewModel = "androidx.lifecycle:lifecycle-viewmodel-ktx:${Versions.lifecycleViewModel}"
        }
        
        object Camera {
            const val core = "androidx.camera:camera-core:${Versions.cameraX}"
            const val camera2 = "androidx.camera:camera-camera2:${Versions.cameraX}"
            const val lifecycle = "androidx.camera:camera-lifecycle:${Versions.cameraX}"
            const val view = "androidx.camera:camera-view:${Versions.cameraX}"
        }
    }

    object Hilt {
        const val android = "com.google.dagger:hilt-android:${Versions.hilt}"
        const val compiler = "com.google.dagger:hilt-android-compiler:${Versions.hilt}"
        const val work = "androidx.hilt:hilt-work:${Versions.hiltWork}"
        const val workCompiler = "androidx.hilt:hilt-compiler:${Versions.hiltWork}"
        const val navigationCompose = "androidx.hilt:hilt-navigation-compose:${Versions.hiltNavigationCompose}"
    }

    object Navigation {
        const val fragment = "androidx.navigation:navigation-fragment-ktx:${Versions.navigation}"
        const val ui = "androidx.navigation:navigation-ui-ktx:${Versions.navigation}"
    }

    object UI {
        const val material = "com.google.android.material:material:${Versions.material}"
    }

    object Test {
        const val junit = "junit:junit:${Versions.junit}"
        const val androidxJunit = "androidx.test.ext:junit:${Versions.androidxJunit}"
        const val espresso = "androidx.test.espresso:espresso-core:${Versions.espresso}"
    }
    
    object Tools {
        const val desugar = "com.android.tools:desugar_jdk_libs:${Versions.desugar}"
    }

    object Kotlin {
        const val stdlib = "org.jetbrains.kotlin:kotlin-stdlib-jdk8:${Versions.kotlinStdlib}"
        const val coroutinesAndroid = "org.jetbrains.kotlinx:kotlinx-coroutines-android:${Versions.coroutines}"
        const val coroutinesCore = "org.jetbrains.kotlinx:kotlinx-coroutines-core:${Versions.coroutines}"
        const val bom = "org.jetbrains.kotlin:kotlin-bom:${Versions.kotlin}"
    }

    object Compose {
        const val bom = "androidx.compose:compose-bom:${Versions.composeBom}"
        const val ui = "androidx.compose.ui:ui"
        const val uiGraphics = "androidx.compose.ui:ui-graphics"
        const val uiToolingPreview = "androidx.compose.ui:ui-tooling-preview"
        const val material3 = "androidx.compose.material3:material3"
        const val runtime = "androidx.compose.runtime:runtime"
        const val uiTooling = "androidx.compose.ui:ui-tooling"
        const val uiTestManifest = "androidx.compose.ui:ui-test-manifest"
    }
} 

==========================================
FILE: settings.gradle.kts
==========================================

pluginManagement {
    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
    // Spezifische Version fÃ¼r AGP
    resolutionStrategy {
        eachPlugin {
            when (requested.id.id) {
                "com.android.application",
                "com.android.library" -> useVersion("8.2.2")
                "org.jetbrains.kotlin.android" -> useVersion("1.9.22")
                "com.google.devtools.ksp" -> useVersion("1.9.22-1.0.17")
                "com.google.dagger.hilt.android" -> useVersion("2.55")
            }
        }
    }
}

dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
        maven { url = uri("https://jitpack.io") }
        maven { url = uri("https://maven.pkg.github.com/opencv/opencv") }
    }
}

rootProject.name = "RouletteTracker"
include(":app")
include(":opencv")

// Diese Feature-Preview erst mal deaktivieren bis wir den Build zum Laufen bekommen
// enableFeaturePreview("TYPESAFE_PROJECT_ACCESSORS")

==========================================
FILE: gradle.properties
==========================================

# Project-wide Gradle settings.
# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.
# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html
# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. For more details, visit
# https://developer.android.com/r/tools/gradle-multi-project-decoupled-projects
org.gradle.parallel=true
# AndroidX package structure to make it clearer which packages are bundled with the
# Android operating system, and which are packaged with your app's APK
# https://developer.android.com/topic/libraries/support-library/androidx-rn
android.useAndroidX=true
# Kotlin code style for this project: "official" or "obsolete":
kotlin.code.style=official
# Enables namespacing of each library's R class so that its R class includes only the
# resources declared in the library itself and none from the library's dependencies,
# thereby reducing the size of the R class for that library
android.nonTransitiveRClass=true
org.gradle.caching=true
org.gradle.configuration-cache=true
kotlin.incremental=true
kapt.use.worker.api=false
kapt.incremental.apt=false
kapt.include.compile.classpath=false
android.defaults.buildfeatures.buildconfig=false
android.nonFinalResIds=false
#org.gradle.debug=false
#kotlin.compiler.trace=true
# Optional: Debug Port konfigurieren
# org.gradle.debug.port=5005
org.gradle.configureondemand=true

==========================================
FILE: gradlew
==========================================

#!/bin/sh

#
# Copyright Â© 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions Â«$varÂ», Â«${var}Â», Â«${var:-default}Â», Â«${var+SET}Â»,
#           Â«${var#prefix}Â», Â«${var%suffix}Â», and Â«$( cmd )Â»;
#         * compound commands having a testable exit status, especially Â«caseÂ»;
#         * various built-in commands including Â«commandÂ», Â«setÂ», and Â«ulimitÂ».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s
' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"

==========================================
FILE: opencv/src/main/aidl/org/opencv/engine/OpenCVEngineInterface.aidl
==========================================

package org.opencv.engine;

// Parcelable-Klassen importieren falls nÃ¶tig
// import android.os.Parcelable;

/**
 * Class provides a Java interface for OpenCV Engine Service. It's synchronous with native OpenCVEngine class.
 */
interface OpenCVEngineInterface
{
    /**
     * @return Returns service version
     */
    int getEngineVersion();

    /**
     * Finds an installed OpenCV library.
     * @param OpenCV version.
     * @return Returns path to OpenCV native libs or an empty string if OpenCV can not be found.
     */
    String getLibPathByVersion(String version);

    /**
     * Tries to install defined version of OpenCV from Google Play.
     * @param OpenCV version.
     * @return Returns true if installation was successful or OpenCV package has been already installed.
     */
    boolean installVersion(String version);

    /**
     * Returns list of libraries in loading order separated by semicolon.
     * @param OpenCV version.
     * @return Returns OpenCV libraries names separated by semicolon.
     */
    String getLibraryList(String version);
} 

==========================================
FILE: opencv/src/main/AndroidManifest.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="org.opencv">

    <uses-sdk android:minSdkVersion="21" />
    
    <application>
        <service android:name="org.opencv.engine.OpenCVEngineService"
            android:exported="false">
            <intent-filter>
                <action android:name="org.opencv.engine.BIND" />
            </intent-filter>
        </service>
    </application>

</manifest>

==========================================
FILE: .gitignore
==========================================

# Gradle files
.gradle/
build/
gradle-app.setting

# Local configuration file
local.properties

# IDE files
*.iml
.idea/
.idea/caches/
.idea/libraries/
.idea/modules.xml
.idea/workspace.xml
.idea/navEditor.xml
.idea/assetWizardSettings.xml

# Android Studio generated files
captures/
.externalNativeBuild/
.cxx/
*.apk
*.aab
*.ap_
*.dex

# Log Files
*.log

# OS specific files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Release/Production files
/app/release
/app/debug
/app/production

# Generated files
bin/
gen/
out/

# Version control
vcs.xml

# Android Profiling
*.hprof

# Navigation safe args generated files
**/build/generated/source/navigation-args/

# Data Binding
**/build/generated/data_binding_base_class_source_out/

# Room Database generated files
**/build/generated/ap_generated_sources/

# KSP generated files
**/build/generated/ksp/

# Kotlin incremental compilation
**/build/tmp/

# Android Resource caches
**/build/intermediates/

# Ignoriere alle OpenCV-Dateien standardmÃ¤ÃŸig
/opencv/**
/opencv-wrapper/**

# Erlaube nur spezifische eigene Implementierungen
!/opencv-wrapper/src/main/java/com/roulette/tracker/**
!/opencv-wrapper/build.gradle.kts

# Minimale OpenCV-Konfigurationsdateien
!/opencv/build.gradle.kts
!/opencv/src/main/aidl/org/opencv/engine/OpenCVEngineInterface.aidl
!/opencv/src/main/AndroidManifest.xml
!/opencv/src/main/cpp/CMakeLists.txt

# CMake temporÃ¤re Dateien
**/CMakeFiles/
**/CMakeCache.txt
**/.cmake/
**/compile_commands.json

# Generierte AIDL-Dateien
**/generated/aidl_source_output_dir/

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\androidTest\java\com\roulette\tracker\ExampleInstrumentedTest.kt
==========================================

package com.roulette.tracker

import androidx.test.platform.app.InstrumentationRegistry
import androidx.test.ext.junit.runners.AndroidJUnit4

import org.junit.Test
import org.junit.runner.RunWith

import org.junit.Assert.*

/**
 * Instrumented test, which will execute on an Android device.
 *
 * See [testing documentation](http://d.android.com/tools/testing).
 */
@RunWith(AndroidJUnit4::class)
class ExampleInstrumentedTest {
    @Test
    fun useAppContext() {
        // Context of the app under test.
        val appContext = InstrumentationRegistry.getInstrumentation().targetContext
        assertEquals("com.roulette.tracker", appContext.packageName)
    }
}

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\AndroidManifest.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <!-- FÃ¼ge diese Zeile hinzu, um OpenCV zu Ã¼berschreiben -->
    <uses-sdk tools:overrideLibrary="org.opencv" />

    <!-- Kamera und Speicher Berechtigungen -->
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.CAMERA" />
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" 
        android:maxSdkVersion="32" />
    <uses-permission android:name="android.permission.READ_MEDIA_IMAGES" />
    <uses-permission android:name="android.permission.READ_MEDIA_VIDEO" />
    <uses-permission android:name="android.permission.MODIFY_AUDIO_SETTINGS" />
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" 
        android:maxSdkVersion="28" />
    
    <!-- Hardware Features -->
    <uses-feature 
        android:name="android.hardware.camera" 
        android:required="false" />
    <uses-feature 
        android:name="android.hardware.camera.autofocus" 
        android:required="false" />

    <application
        android:name=".RouletteApplication"
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.RouletteTracker"
        tools:targetApi="31">
        
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:screenOrientation="portrait"
            android:configChanges="orientation|keyboardHidden">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <activity 
            android:name=".SettingsActivity"
            android:exported="false"
            android:screenOrientation="portrait" />

        <activity 
            android:name=".StatisticsActivity"
            android:exported="false"
            android:screenOrientation="portrait" />

        <activity 
            android:name=".TrackingActivity"
            android:exported="false"
            android:screenOrientation="portrait" />

        <provider
            android:name="androidx.core.content.FileProvider"
            android:authorities="${applicationId}.provider"
            android:exported="false"
            android:grantUriPermissions="true">
            <meta-data
                android:name="android.support.FILE_PROVIDER_PATHS"
                android:resource="@xml/file_paths" />
        </provider>

    </application>
</manifest> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\PredictionEngine.kt
==========================================

package com.roulette.tracker

import android.content.Context
import android.speech.tts.TextToSpeech
import java.util.*
import com.roulette.tracker.data.*
import android.util.Log
import kotlin.math.abs
import kotlin.math.PI
import com.roulette.tracker.ml.MLModel
import javax.inject.Inject
import javax.inject.Singleton
import timber.log.Timber

@Singleton
class PredictionEngine @Inject constructor(
    private val context: Context
) {
    private var mlModel: MLModel? = null
    private var tts: TextToSpeech? = null
    
    init {
        initializeTTS()
    }
    
    private fun initializeTTS() {
        tts = TextToSpeech(context) { status ->
            if (status == TextToSpeech.SUCCESS) {
                tts?.language = Locale.getDefault()
            } else {
                Timber.e("TTS Initialisierung fehlgeschlagen mit Status: $status")
            }
        }
    }
    
    private val rouletteNumbers = listOf(
        0, 32, 15, 19, 4, 21, 2, 25, 17, 34, 6, 27, 13, 36, 11, 30,
        8, 23, 10, 5, 24, 16, 33, 1, 20, 14, 31, 9, 22, 18, 29, 7,
        28, 12, 35, 3, 26
    )

    fun predict(ballData: BallData, wheelData: WheelData): PredictionResult {
        if (!isValidInput(ballData, wheelData)) {
            return PredictionResult(-1, 0.0)
        }

        val predictedNumber = calculatePredictedNumber(ballData, wheelData)
        val confidence = calculateConfidence(ballData, wheelData).toDouble()
        
        if (confidence > 0.8) {
            playAudioPrediction(predictedNumber)
        }
        
        return PredictionResult(
            predictedNumber = predictedNumber,
            confidence = confidence
        )
    }

    private fun isValidInput(ballData: BallData, wheelData: WheelData): Boolean {
        return ballData.velocity >= MIN_BALL_VELOCITY && 
               abs(wheelData.rotationSpeed) >= MIN_WHEEL_SPEED
    }

    private fun calculateTimeToLanding(ballData: BallData): Double {
        return (WHEEL_RADIUS * PI) / ballData.velocity
    }

    private fun predictLandingPosition(ballData: BallData, timeToLanding: Double): Point {
        val deceleratedVelocity = ballData.velocity * FRICTION_FACTOR
        val x = (ballData.currentPosition.x + deceleratedVelocity * timeToLanding) % (2 * PI)
        val y = ballData.currentPosition.y
        return Point(x, y)
    }

    private fun predictWheelPosition(
        currentAngle: Double, 
        rotationSpeed: Double, 
        timeToLanding: Double
    ): Double {
        return (currentAngle + rotationSpeed * timeToLanding) % 360.0
    }

    private fun determineNumberAtPosition(angle: Double): Int {
        val normalizedAngle = (angle + 360.0) % 360.0
        val index = ((normalizedAngle / 360.0) * rouletteNumbers.size).toInt()
        return rouletteNumbers[index]
    }

    private fun calculateConfidence(ballData: BallData, wheelData: WheelData): Float {
        var confidence = 100f
        
        confidence *= when {
            ballData.velocity > MAX_RELIABLE_BALL_VELOCITY -> 0.8f
            abs(wheelData.rotationSpeed) > MAX_RELIABLE_WHEEL_SPEED -> 0.8f
            calculateTimeToLanding(ballData) > MAX_RELIABLE_PREDICTION_TIME -> 0.7f
            else -> 1.0f
        }

        return confidence.coerceIn(0f, 100f)
    }

    private fun playAudioPrediction(number: Int) {
        tts?.speak(
            "Vorhergesagte Nummer: $number", 
            TextToSpeech.QUEUE_FLUSH, 
            null, 
            null
        )
    }
    
    fun cleanup() {
        tts?.apply {
            stop()
            shutdown()
        }
        mlModel = null
    }

    private fun calculatePredictedNumber(ballData: BallData, wheelData: WheelData): Int {
        val timeToLanding = calculateTimeToLanding(ballData)
        val landingPosition = predictLandingPosition(ballData, timeToLanding)
        val wheelPositionAtLanding = predictWheelPosition(
            wheelData.currentAngle,
            wheelData.rotationSpeed,
            timeToLanding
        )

        announcePosition(landingPosition)
        return determineNumberAtPosition(wheelPositionAtLanding)
    }

    private fun announcePosition(position: Point) {
        tts?.speak(
            "Ball landet bei Position ${position.x.toInt()}, ${position.y.toInt()}", 
            TextToSpeech.QUEUE_FLUSH,
            null,
            null
        )
    }

    companion object {
        private const val WHEEL_RADIUS = 400.0
        private const val FRICTION_FACTOR = 0.95
        private const val MIN_BALL_VELOCITY = 1.0
        private const val MIN_WHEEL_SPEED = 0.1
        private const val MAX_RELIABLE_BALL_VELOCITY = 100f
        private const val MAX_RELIABLE_WHEEL_SPEED = 50.0
        private const val MAX_RELIABLE_PREDICTION_TIME = 5.0
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\RouletteApplication.kt
==========================================

package com.roulette.tracker

import android.app.Application
import androidx.hilt.work.HiltWorkerFactory
import androidx.work.Configuration
import dagger.hilt.android.HiltAndroidApp
import javax.inject.Inject

@HiltAndroidApp
class RouletteApplication : Application(), Configuration.Provider {
    @Inject
    lateinit var workerFactory: HiltWorkerFactory

    override fun getWorkManagerConfiguration(): Configuration {
        return Configuration.Builder()
            .setWorkerFactory(workerFactory)
            .setMinimumLoggingLevel(android.util.Log.DEBUG)  // Optional fÃ¼r besseres Debugging
            .build()
    }

    override fun onCreate() {
        super.onCreate()
        // WorkManager.initialize(this, workManagerConfiguration)  // Nicht mehr nÃ¶tig, wird automatisch gemacht
        // Initialisierung hier...
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\SettingsManager.kt
==========================================

package com.roulette.tracker

import android.content.Context
import android.content.SharedPreferences
import dagger.hilt.android.qualifiers.ApplicationContext
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class SettingsManager @Inject constructor(
    @ApplicationContext private val context: Context
) {
    private val prefs: SharedPreferences = context.getSharedPreferences(
        PREFS_NAME,
        Context.MODE_PRIVATE
    )

    fun saveSettings(key: String, value: String) {
        prefs.edit().putString(key, value).apply()
    }

    fun getSetting(key: String, defaultValue: String = ""): String {
        return prefs.getString(key, defaultValue) ?: defaultValue
    }

    companion object {
        private const val PREFS_NAME = "roulette_tracker_settings"
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\camera\CameraConfig.kt
==========================================

package com.roulette.tracker.camera

import android.content.Context
import android.util.Log
import android.util.Size
import javax.inject.Inject
import javax.inject.Singleton
import kotlin.math.min

@Singleton
class CameraConfig @Inject constructor(
    private val context: Context
) {
    fun getOptimalPreviewSize(
        targetWidth: Int,
        targetHeight: Int,
        maxWidth: Int,
        maxHeight: Int,
        aspectRatio: Size
    ): Size {
        // Berechne das Ziel-SeitenverhÃ¤ltnis direkt in der HÃ¶henberechnung
        val targetArea = targetWidth * targetHeight
        
        // Finde die beste GrÃ¶ÃŸe basierend auf Zielbereich
        val width = if (targetArea > maxWidth * maxHeight) {
            maxWidth
        } else {
            min(targetWidth, maxWidth)
        }
        
        // Berechne HÃ¶he direkt mit dem SeitenverhÃ¤ltnis von aspectRatio
        val height = (width / (aspectRatio.width.toFloat() / aspectRatio.height))
            .toInt()
            .coerceAtMost(maxHeight)
        
        return Size(width, height).also { size ->
            Log.d(TAG, "Selected preview size: $size (area: $targetArea)")
        }
    }

    fun getOptimalImageAnalysisSize(): Size {
        return Size(1280, 720) // HD fÃ¼r gute Performance/QualitÃ¤t-Balance
    }

    companion object {
        private const val TAG = "CameraConfig"
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\camera\CameraError.kt
==========================================

package com.roulette.tracker.camera

data class CameraError(
    val timestamp: Long = System.currentTimeMillis(),
    val message: String,
    val exception: Exception? = null
) 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\camera\CameraErrorHandler.kt
==========================================

package com.roulette.tracker.camera

import javax.inject.Inject
import javax.inject.Singleton
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow

@Singleton
class CameraErrorHandler @Inject constructor() {
    private val _errors = MutableStateFlow<List<CameraError>>(emptyList())
    val errors: StateFlow<List<CameraError>> = _errors
    
    fun handleError(error: CameraError) {
        _errors.value = _errors.value + error
    }
    
    fun clearErrors() {
        _errors.value = emptyList()
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\camera\CameraManager.kt
==========================================

package com.roulette.tracker.camera

import android.content.Context
import android.util.Log
import androidx.camera.core.*
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.camera.view.PreviewView
import androidx.core.content.ContextCompat
import androidx.lifecycle.LifecycleOwner
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors
import kotlin.coroutines.resume
import kotlin.coroutines.suspendCoroutine
import javax.inject.Inject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.asExecutor

sealed class CameraResult {
    object Success : CameraResult()
    data class Error(val exception: Exception) : CameraResult()
}

class CameraManager @Inject constructor(
    private val context: Context,
    private val lifecycleOwner: LifecycleOwner,
    private val systemCameraManager: android.hardware.camera2.CameraManager,
    private val openCVLoader: OpenCVLoader
) {
    private var cameraExecutor: ExecutorService = Executors.newSingleThreadExecutor()
    private var imageAnalyzer: ImageAnalysis? = null
    private var camera: Camera? = null

    suspend fun startCamera(
        previewView: PreviewView,
        imageAnalyzer: ImageAnalysis.Analyzer
    ) = suspendCoroutine { continuation ->
        try {
            val cameraProviderFuture = ProcessCameraProvider.getInstance(context)

            cameraProviderFuture.addListener({
                try {
                    val cameraProvider = cameraProviderFuture.get()

                    val preview = Preview.Builder()
                        .build()
                        .also {
                            it.setSurfaceProvider(previewView.surfaceProvider)
                        }

                    this.imageAnalyzer = ImageAnalysis.Builder()
                        .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)
                        .build()
                        .also {
                            it.setAnalyzer(cameraExecutor, imageAnalyzer)
                        }

                    val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA

                    cameraProvider.unbindAll()
                    camera = cameraProvider.bindToLifecycle(
                        lifecycleOwner,
                        cameraSelector,
                        preview,
                        this.imageAnalyzer
                    )
                    continuation.resume(CameraResult.Success)
                } catch (e: Exception) {
                    Log.e(TAG, ERROR_USE_CASE_BINDING_FAILED, e)
                    continuation.resume(CameraResult.Error(e))
                }
            }, ContextCompat.getMainExecutor(context))
        } catch (e: Exception) {
            Log.e(TAG, ERROR_USE_CASE_BINDING_FAILED, e)
            continuation.resume(CameraResult.Error(e))
        }
    }

    suspend fun startCamera(
        preview: PreviewView,
        analyzer: ImageAnalysis.Analyzer,
        resolutionSelector: ResolutionSelector,
        frameRate: Int,
        useHardwareAcceleration: Boolean
    ) = suspendCoroutine { continuation ->
        try {
            val cameraProviderFuture = ProcessCameraProvider.getInstance(context)

            cameraProviderFuture.addListener({
                try {
                    val cameraProvider = cameraProviderFuture.get()

                    val preview = Preview.Builder()
                        .setResolutionSelector(resolutionSelector)
                        .build()
                        .also {
                            it.setSurfaceProvider(preview.surfaceProvider)
                        }

                    val imageAnalysis = ImageAnalysis.Builder()
                        .setResolutionSelector(resolutionSelector)
                        .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)
                        .setTargetFrameRate(frameRate)
                        .setOutputImageFormat(ImageAnalysis.OUTPUT_IMAGE_FORMAT_YUV_420_888)
                        .setImageQueueDepth(1)
                        .build()
                        .also {
                            it.setAnalyzer(
                                if (useHardwareAcceleration) cameraExecutor else Dispatchers.Default.asExecutor(),
                                analyzer
                            )
                        }

                    val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA

                    cameraProvider.unbindAll()
                    camera = cameraProvider.bindToLifecycle(
                        lifecycleOwner,
                        cameraSelector,
                        preview,
                        imageAnalysis
                    )
                    continuation.resume(CameraResult.Success)
                } catch (e: Exception) {
                    Log.e(TAG, ERROR_USE_CASE_BINDING_FAILED, e)
                    continuation.resume(CameraResult.Error(e))
                }
            }, ContextCompat.getMainExecutor(context))
        } catch (e: Exception) {
            Log.e(TAG, ERROR_USE_CASE_BINDING_FAILED, e)
            continuation.resume(CameraResult.Error(e))
        }
    }

    fun stopCamera() {
        cameraExecutor.shutdown()
    }

    companion object {
        private const val TAG = "CameraManager"
        private const val ERROR_USE_CASE_BINDING_FAILED = "Anwendungsfallbindung fehlgeschlagen"
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\camera\CameraPreviewManager.kt
==========================================

package com.roulette.tracker.camera

import android.content.Context
import android.graphics.Bitmap
import android.graphics.Matrix
import android.util.Log
import android.widget.ImageView
import org.opencv.android.Utils
import org.opencv.core.Mat

class CameraPreviewManager(private val context: Context) {
    private var previewBitmap: Bitmap? = null
    private val rotationMatrix = Matrix().apply {
        postRotate(90f)  // Kamera ist standardmÃ¤ÃŸig um 90Â° gedreht
    }

    fun showPreview(frame: Mat, previewView: ImageView) {
        try {
            // Bitmap recyclen wenn nÃ¶tig
            previewBitmap?.recycle()
            
            // Neue Bitmap erstellen
            previewBitmap = Bitmap.createBitmap(
                frame.cols(),
                frame.rows(),
                Bitmap.Config.ARGB_8888
            )
            
            // OpenCV Mat in Bitmap konvertieren
            Utils.matToBitmap(frame, previewBitmap)
            
            // Bitmap rotieren wenn nÃ¶tig
            val rotatedBitmap = Bitmap.createBitmap(
                previewBitmap!!,
                0,
                0,
                previewBitmap!!.width,
                previewBitmap!!.height,
                rotationMatrix,
                true
            )
            
            // In UI Thread anzeigen
            previewView.post {
                previewView.setImageBitmap(rotatedBitmap)
            }
            
        } catch (e: Exception) {
            Log.e(TAG, "Error showing preview: ${e.message}")
        }
    }

    fun release() {
        previewBitmap?.recycle()
        previewBitmap = null
    }

    companion object {
        private const val TAG = "CameraPreviewManager"
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\camera\FrameAnalyzer.kt
==========================================

@file:OptIn(ExperimentalUnsignedTypes::class)
package com.roulette.tracker.camera

import android.util.Log
import androidx.camera.core.ImageAnalysis
import androidx.camera.core.ImageProxy
import org.opencv.core.Mat
import org.opencv.core.CvType
import org.opencv.imgproc.Imgproc
import java.nio.ByteBuffer
import javax.inject.Inject
import timber.log.Timber
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow

class FrameAnalyzer @Inject constructor(
    private val onFrameAnalyzed: (Mat) -> Unit,
    private val config: FrameAnalyzerConfig
) : ImageAnalysis.Analyzer {

    private var lastProcessingTimeMs: Long = 0
    private val _analyzerMetrics = MutableStateFlow(AnalyzerMetrics())
    val analyzerMetrics: StateFlow<AnalyzerMetrics> = _analyzerMetrics

    override fun analyze(image: ImageProxy) {
        val currentTime = System.currentTimeMillis()
        if (currentTime - lastProcessingTimeMs < config.processingInterval) {
            image.close()
            updateMetrics(skipped = true)
            return
        }

        var mat: Mat? = null
        try {
            mat = convertImageToMat(image)
            performColorConversion(mat)
            
            onFrameAnalyzed(mat)
            lastProcessingTimeMs = currentTime
            updateMetrics(processed = true)
        } catch (e: Exception) {
            Timber.e(e, "Frame analysis failed")
            updateMetrics(error = true)
            mat?.safeRelease()
        } finally {
            image.close()
        }
    }

    private fun convertImageToMat(image: ImageProxy): Mat {
        val buffer = image.planes[0].buffer
        val data = buffer.toByteArray()
        return Mat(image.height, image.width, CvType.CV_8UC1).apply {
            put(0, 0, data)
        }
    }

    private fun performColorConversion(mat: Mat) {
        when (config.colorConversion) {
            ColorConversion.YUV2BGR -> Imgproc.cvtColor(mat, mat, Imgproc.COLOR_YUV2BGR_NV21)
            ColorConversion.YUV2RGB -> Imgproc.cvtColor(mat, mat, Imgproc.COLOR_YUV2RGB_NV21)
            ColorConversion.NONE -> { /* Keine Konvertierung */ }
        }
    }

    private fun Mat.safeRelease() {
        try {
            if (!empty()) {
                release()
            }
        } catch (e: Exception) {
            Timber.e(e, "Error releasing Mat")
        }
    }

    private fun ByteBuffer.toByteArray(): ByteArray {
        rewind()
        val data = ByteArray(remaining())
        get(data)
        return data
    }

    private fun updateMetrics(
        processed: Boolean = false,
        skipped: Boolean = false,
        error: Boolean = false
    ) {
        val current = _analyzerMetrics.value
        _analyzerMetrics.value = current.copy(
            processedFrames = current.processedFrames + if (processed) 1 else 0,
            skippedFrames = current.skippedFrames + if (skipped) 1 else 0,
            errorFrames = current.errorFrames + if (error) 1 else 0,
            lastProcessingTime = if (processed) System.currentTimeMillis() - lastProcessingTimeMs else current.lastProcessingTime
        )
    }

    companion object {
        private const val TAG = "FrameAnalyzer"
    }
}

data class AnalyzerMetrics(
    val processedFrames: Long = 0,
    val skippedFrames: Long = 0,
    val errorFrames: Long = 0,
    val lastProcessingTime: Long = 0
) 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\camera\FrameAnalyzerConfig.kt
==========================================

package com.roulette.tracker.camera

data class FrameAnalyzerConfig(
    val targetFps: Int = 30,
    val processingInterval: Long = (1000 / targetFps).toLong(),
    val colorConversion: ColorConversion = ColorConversion.YUV2BGR
) {
    enum class ColorConversion {
        YUV2BGR,
        YUV2RGB,
        NONE
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\camera\FrameAnalyzerFactory.kt
==========================================

package com.roulette.tracker.camera

import org.opencv.core.Mat
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class FrameAnalyzerFactory @Inject constructor() {
    
    fun create(
        onFrameAnalyzed: (Mat) -> Unit,
        config: FrameAnalyzerConfig = FrameAnalyzerConfig()
    ): FrameAnalyzer {
        return FrameAnalyzer(onFrameAnalyzed, config)
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\camera\OpenCVLoader.kt
==========================================

package com.roulette.tracker.camera

import javax.inject.Inject

class OpenCVLoader @Inject constructor() {
    // Implementierung
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\data\AppDatabase.kt
==========================================

package com.roulette.tracker.data

import android.content.Context
import androidx.room.Database
import androidx.room.Room
import androidx.room.RoomDatabase
import com.roulette.tracker.data.dao.SimulationDao
import com.roulette.tracker.data.entities.SimulationEntity
import com.roulette.tracker.data.entities.SimulationResult

@Database(
    entities = [
        SimulationEntity::class,
        SimulationResult::class
    ],
    version = 2,
    exportSchema = false
)
abstract class AppDatabase : RoomDatabase() {
    abstract fun simulationDao(): SimulationDao

    companion object {
        @Volatile
        private var instance: AppDatabase? = null

        fun getDatabase(context: Context): AppDatabase {
            return instance ?: synchronized(this) {
                Room.databaseBuilder(
                    context.applicationContext,
                    AppDatabase::class.java,
                    "roulette_database"
                )
                .addMigrations(MIGRATION_1_2)
                .fallbackToDestructiveMigration()
                .build()
                .also { instance = it }
            }
        }
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\data\BallData.kt
==========================================

package com.roulette.tracker.data

data class BallData(
    val currentPosition: Point,
    val velocity: Double,
    val confidence: Double,
    val timestamp: Long = System.currentTimeMillis()
) 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\data\DatabaseMigrations.kt
==========================================

package com.roulette.tracker.data

import androidx.room.migration.Migration
import androidx.sqlite.db.SupportSQLiteDatabase

val MIGRATION_1_2 = object : Migration(1, 2) {
    override fun migrate(database: SupportSQLiteDatabase) {
        // Hier kannst du die SchemaÃ¤nderungen fÃ¼r die Migration von Version 1 zu Version 2 definieren
        // Zum Beispiel:
        // database.execSQL("ALTER TABLE simulation_results ADD COLUMN new_column INTEGER")
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\data\Models.kt
==========================================

package com.roulette.tracker.data

data class BallData(
    val position: Float,
    val velocity: Float,
    val timestamp: Long
)

data class WheelData(
    val position: Float,
    val velocity: Float,
    val timestamp: Long
)

data class PredictionResult(
    val predictedNumber: Int,
    val confidence: Float,
    val timeToLanding: Float
)

data class AnalysisResult(
    val ballData: BallData?,
    val wheelData: WheelData?,
    val prediction: PredictionResult?
)

data class SimulationData(
    val predictedNumber: Int,
    val accuracy: Float
)

data class TrackingPosition(
    val currentPosition: Float,
    val rotationSpeed: Float,
    val centerPoint: Point? = null,
    val currentAngle: Float = 0f,
    val visibleNumbers: List<Int> = emptyList(),
    val predictedLandingTime: Long = 0L
) 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\data\Point.kt
==========================================

package com.roulette.tracker.data

data class Point(
    val x: Double,
    val y: Double
) 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\data\PredictionResult.kt
==========================================

package com.roulette.tracker.data

data class PredictionResult(
    val predictedNumber: Int,
    val confidence: Double
) 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\data\StatisticsProcessor.kt
==========================================

package com.roulette.tracker.data

import com.roulette.tracker.data.entities.SimulationResult
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import kotlinx.coroutines.async
import kotlinx.coroutines.coroutineScope
import kotlin.math.abs

object StatisticsProcessor {
    suspend fun process(data: List<SimulationResult>) = coroutineScope {
        withContext(Dispatchers.Default) {
            // Parallele Berechnung der verschiedenen Statistiken
            val accuracyDataDeferred = async { calculateAccuracyData(data) }
            val predictionDataDeferred = async { extractPredictionData(data) }
            val last100StatsDeferred = async { calculateStats(data.takeLast(100)) }
            val last1000StatsDeferred = async { calculateStats(data.takeLast(1000)) }
            val extendedStatsDeferred = async { calculateExtendedStats(data) }

            StatisticsData(
                accuracyData = accuracyDataDeferred.await(),
                predictionData = predictionDataDeferred.await(),
                last100Stats = last100StatsDeferred.await(),
                last1000Stats = last1000StatsDeferred.await(),
                extendedStats = extendedStatsDeferred.await()
            )
        }
    }

    private fun calculateAccuracyData(data: List<SimulationResult>): List<Float> {
        return data.asSequence()
            .map { it.accuracy.toFloat() }
            .toList()
    }

    private fun extractPredictionData(data: List<SimulationResult>): List<Pair<Int, Int>> {
        return data.asSequence()
            .map { Pair(it.predictedNumber, it.actualNumber) }
            .toList()
    }

    private fun calculateStats(data: List<SimulationResult>): StatsSummary {
        if (data.isEmpty()) return StatsSummary()

        val totalPredictions = data.size
        val correctPredictions = data.count { it.predictedNumber == it.actualNumber }
        val accuracy = (correctPredictions.toFloat() / totalPredictions) * 100
        val averageError = data.asSequence()
            .map { abs(it.predictedNumber - it.actualNumber) }
            .average()
            .toFloat()

        return StatsSummary(
            totalPredictions = totalPredictions,
            correctPredictions = correctPredictions,
            accuracy = accuracy,
            averageError = averageError
        )
    }

    private fun calculateExtendedStats(data: List<SimulationResult>): ExtendedStats {
        if (data.isEmpty()) return ExtendedStats()

        val numberFrequency = data.asSequence()
            .groupBy { it.actualNumber }
            .mapValues { it.value.size }
            .toMap()
        
        return ExtendedStats(
            mostCommonNumber = numberFrequency.maxByOrNull { it.value }?.key ?: 0,
            leastCommonNumber = numberFrequency.minByOrNull { it.value }?.key ?: 0,
            maxConsecutiveCorrect = calculateMaxConsecutiveCorrect(data),
            totalPredictions = data.size,
            numberFrequencies = numberFrequency
        )
    }

    private fun calculateMaxConsecutiveCorrect(data: List<SimulationResult>): Int {
        return data.asSequence()
            .windowed(2)
            .fold(Triple(0, 0, 0)) { (max, current, _), window ->
                val (result1, result2) = window
                when {
                    result1.predictedNumber == result1.actualNumber && 
                    result2.predictedNumber == result2.actualNumber -> 
                        Triple(maxOf(max, current + 1), current + 1, 1)
                    result2.predictedNumber == result2.actualNumber -> 
                        Triple(max, 1, 1)
                    else -> 
                        Triple(max, 0, 0)
                }
            }.first
    }

    // Cache fÃ¼r hÃ¤ufig verwendete Berechnungen
    private val statsCache = mutableMapOf<String, Any>()
    
    private fun getCachedValue(key: String, calculator: () -> Any): Any {
        return statsCache.getOrPut(key, calculator)
    }
    
    fun clearCache() {
        statsCache.clear()
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\data\TimeRange.kt
==========================================

package com.roulette.tracker.data

enum class TimeRange {
    LAST_24H,
    LAST_WEEK,
    LAST_MONTH,
    ALL_TIME;

    fun getDisplayName(): String = when(this) {
        LAST_24H -> "Letzte 24 Stunden"
        LAST_WEEK -> "Letzte Woche"
        LAST_MONTH -> "Letzter Monat"
        ALL_TIME -> "Alle Zeiten"
    }

    fun getMillis(): Long = when(this) {
        LAST_24H -> 24 * 60 * 60 * 1000L
        LAST_WEEK -> 7 * 24 * 60 * 60 * 1000L
        LAST_MONTH -> 30 * 24 * 60 * 60 * 1000L
        ALL_TIME -> 0L
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\data\TrackingState.kt
==========================================

package com.roulette.tracker.data

sealed class TrackingState {
    object Initializing : TrackingState()
    object Running : TrackingState()
    object BallNotFound : TrackingState()
    object WheelNotFound : TrackingState()
    object Idle : TrackingState()
    object TrackingBall : TrackingState()
    object TrackingWheel : TrackingState()
    data class Predicting(val timeRemaining: Long) : TrackingState()
    data class Success(val result: PredictionResult) : TrackingState()
    data class Error(val message: String) : TrackingState()
    object ResultReady : TrackingState()

    var message: String? = null
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\data\WheelData.kt
==========================================

package com.roulette.tracker.data

data class WheelData(
    val currentAngle: Double,
    val rotationSpeed: Double,
    val confidence: Double,
    val timestamp: Long = System.currentTimeMillis()
) {
    fun isValid(): Boolean = confidence > 0.0 && rotationSpeed >= 0.0
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\data\dao\SimulationDao.kt
==========================================

package com.roulette.tracker.data.dao

import androidx.room.*
import com.roulette.tracker.data.entities.SimulationEntity
import com.roulette.tracker.data.entities.SimulationResult
import kotlinx.coroutines.flow.Flow

@Dao
interface SimulationDao {
    @Query("SELECT * FROM simulations")
    fun getAllSimulations(): Flow<List<SimulationEntity>>

    @Query("SELECT * FROM simulation_results")
    fun getAllResults(): Flow<List<SimulationResult>>

    @Query("SELECT * FROM simulation_results WHERE id = :id")
    fun getResultById(id: Long): Flow<SimulationResult?>

    @Query("SELECT AVG(CASE WHEN actualNumber = predictedNumber THEN 1.0 ELSE 0.0 END) FROM simulation_results WHERE actualNumber IS NOT NULL")
    fun getAccuracyRate(): Flow<Float>

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(result: SimulationResult)

    @Delete
    suspend fun delete(result: SimulationResult)

    @Query("DELETE FROM simulation_results")
    suspend fun deleteAll()

    @Query("""
        SELECT * FROM simulation_results 
        WHERE timestamp >= :since 
        AND timestamp <= :now
        ORDER BY timestamp DESC
    """)
    fun getResultsSince(since: Long, now: Long = System.currentTimeMillis()): Flow<List<SimulationResult>>

    @Insert
    suspend fun insertSimulation(simulation: SimulationEntity)

    @Query("UPDATE simulation_results SET actualNumber = :actualNumber WHERE id = :resultId")
    suspend fun updateActualNumber(resultId: Long, actualNumber: Int)

    @Query("DELETE FROM simulation_results WHERE timestamp < :timestamp")
    suspend fun deleteOlderThan(timestamp: Long)
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\data\entities\SimulationEntity.kt
==========================================

package com.roulette.tracker.data.entities

import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity(tableName = "simulations")
data class SimulationEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,
    val timestamp: Long = System.currentTimeMillis(),
    val settings: String  // JSON der Simulationseinstellungen
) 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\data\entities\SimulationResult.kt
==========================================

package com.roulette.tracker.data.entities

import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity(tableName = "simulation_results")
data class SimulationResult(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,
    val timestamp: Long = System.currentTimeMillis(),
    val predictedNumber: Int,
    val actualNumber: Int? = null,
    val confidence: Double
) 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\data\models\ExtendedStats.kt
==========================================

package com.roulette.tracker.data.models

data class ExtendedStats(
    val mostCommonNumber: Int = 0,
    val leastCommonNumber: Int = 0,
    val maxConsecutiveCorrect: Int = 0,
    val totalPredictions: Int = 0,
    val numberFrequencies: Map<Int, Int> = emptyMap(),
    val averageAccuracy: Float = 0f,
    val standardDeviation: Float = 0f,
    val winRate: Float = 0f,
    val lastUpdateTimestamp: Long = System.currentTimeMillis()
) {
    fun getHotNumbers(): List<Int> = 
        numberFrequencies.entries
            .sortedByDescending { it.value }
            .take(5)
            .map { it.key }

    fun getColdNumbers(): List<Int> = 
        numberFrequencies.entries
            .sortedBy { it.value }
            .take(5)
            .map { it.key }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\data\repository\Repository.kt
==========================================

package com.roulette.tracker.data.repository

import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.first

interface Repository<T> {
    fun getAll(): Flow<List<T>>
    fun getById(id: Long): Flow<T?>
    suspend fun insert(item: T): Long
    suspend fun delete(item: T)
    suspend fun deleteAll()
    suspend fun update(item: T)
    suspend fun deleteOlderThan(timestamp: Long)
    
    // Optionale Methoden mit Default-Implementierung
    suspend fun insertAll(items: List<T>) {
        items.forEach { insert(it) }
    }
    
    suspend fun exists(id: Long): Boolean {
        return getById(id).first() != null
    }
}

@Singleton
class SimulationRepositoryImpl @Inject constructor(
    private val simulationDao: SimulationDao
) : Repository<SimulationResult> {
    override fun getAll(): Flow<List<SimulationResult>> = simulationDao.getAllResults()
    
    override fun getById(id: Long): Flow<SimulationResult?> = simulationDao.getById(id)
    
    override suspend fun insert(item: SimulationResult): Long = simulationDao.insert(item)
    
    override suspend fun update(item: SimulationResult) {
        simulationDao.updateActualNumber(item.id, item.actualNumber ?: return)
    }
    
    override suspend fun delete(item: SimulationResult) {
        // Implement if needed
    }
    
    override suspend fun deleteAll() = simulationDao.deleteAll()
    
    override suspend fun deleteOlderThan(timestamp: Long) {
        // Implement if needed
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\data\repository\SimulationRepository.kt
==========================================

package com.roulette.tracker.data.repository

import com.roulette.tracker.data.dao.SimulationDao
import com.roulette.tracker.data.entities.SimulationResult
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.collect
import kotlinx.coroutines.flow.withContext
import kotlinx.coroutines.Dispatchers
import javax.inject.Inject
import javax.inject.Singleton
import timber.log.Timber

@Singleton
class SimulationRepository @Inject constructor(
    private val simulationDao: SimulationDao
) : Repository<SimulationResult> {
    val allResults: Flow<List<SimulationResult>> = simulationDao.getAllResults()
    val accuracyRate: Flow<Float> = simulationDao.getAccuracyRate()

    override fun getAll(): Flow<List<SimulationResult>> = 
        simulationDao.getAllResults()
    
    override fun getById(id: Long): Flow<SimulationResult?> = 
        simulationDao.getResultById(id)
    
    override suspend fun insert(item: SimulationResult): Long {
        simulationDao.insert(item)
        return item.id
    }
    
    override suspend fun update(item: SimulationResult) {
        simulationDao.updateActualNumber(item.id, item.actualNumber ?: return)
    }
    
    override suspend fun delete(item: SimulationResult) {
        simulationDao.delete(item)
    }
    
    override suspend fun deleteAll() = 
        simulationDao.deleteAll()
    
    override suspend fun deleteOlderThan(timestamp: Long) {
        simulationDao.deleteOlderThan(timestamp)
    }

    fun getResultsSince(timestamp: Long): Flow<List<SimulationResult>> {
        return simulationDao.getResultsSince(timestamp)
    }

    suspend fun getStatisticsForTimeRange(range: TimeRange): Flow<List<SimulationResult>> = flow {
        withContext(Dispatchers.IO) {
            val startTime = when (range) {
                TimeRange.LAST_WEEK -> System.currentTimeMillis() - 7 * 24 * 60 * 60 * 1000
                TimeRange.LAST_MONTH -> System.currentTimeMillis() - 30 * 24 * 60 * 60 * 1000
                TimeRange.ALL_TIME -> 0
            }
            
            simulationDao.getSimulationResultsAfter(startTime)
                .catch { e -> 
                    Timber.e(e, "Fehler beim Laden der Simulationsergebnisse")
                    emit(emptyList())
                }
                .collect { results ->
                    emit(results)
                }
        }
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\data\repository\SimulationRepositoryImpl.kt
==========================================

package com.roulette.tracker.data.repository

import com.roulette.tracker.data.dao.SimulationDao
import com.roulette.tracker.data.entities.SimulationResult
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.flowOn
import kotlinx.coroutines.Dispatchers
import javax.inject.Inject
import javax.inject.Singleton
import timber.log.Timber

@Singleton
class SimulationRepositoryImpl @Inject constructor(
    private val simulationDao: SimulationDao
) : Repository<SimulationResult> {
    
    override fun getAll(): Flow<List<SimulationResult>> = 
        simulationDao.getAllResults()
            .flowOn(Dispatchers.IO)
            .catch { e ->
                Timber.e(e, "Fehler beim Laden aller Ergebnisse")
                emit(emptyList())
            }
    
    override fun getById(id: Long): Flow<SimulationResult?> =
        simulationDao.getResultById(id)
            .flowOn(Dispatchers.IO)
            .catch { e ->
                Timber.e(e, "Fehler beim Laden des Ergebnisses mit ID: $id")
                emit(null)
            }
    
    override suspend fun insert(item: SimulationResult): Long {
        return try {
            simulationDao.insert(item)
        } catch (e: Exception) {
            Timber.e(e, "Fehler beim EinfÃ¼gen des Ergebnisses")
            -1L
        }
    }
    
    override suspend fun update(item: SimulationResult) {
        try {
            item.actualNumber?.let { number ->
                simulationDao.updateActualNumber(item.id, number)
            }
        } catch (e: Exception) {
            Timber.e(e, "Fehler beim Aktualisieren des Ergebnisses: ${item.id}")
        }
    }
    
    override suspend fun delete(item: SimulationResult) {
        try {
            simulationDao.delete(item)
        } catch (e: Exception) {
            Timber.e(e, "Fehler beim LÃ¶schen des Ergebnisses: ${item.id}")
        }
    }
    
    override suspend fun deleteAll() {
        try {
            simulationDao.deleteAll()
        } catch (e: Exception) {
            Timber.e(e, "Fehler beim LÃ¶schen aller Ergebnisse")
        }
    }

    override suspend fun deleteOlderThan(timestamp: Long) {
        simulationDao.deleteOlderThan(timestamp)
    }

    // ZusÃ¤tzliche spezifische Methoden
    suspend fun getStatisticsForTimeRange(range: TimeRange): Flow<List<SimulationResult>> = flow {
        withContext(Dispatchers.IO) {
            val startTime = range.getMillis()
            simulationDao.getSimulationResultsAfter(startTime)
                .catch { e -> 
                    Timber.e(e, "Fehler beim Laden der Statistiken fÃ¼r Zeitraum: $range")
                    emit(emptyList())
                }
                .collect { results -> emit(results) }
        }
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\detection\ObjectDetector.kt
==========================================

import android.content.Context
import android.graphics.Bitmap
import android.util.Log
import org.opencv.android.Utils
import org.opencv.core.*
import org.opencv.imgproc.Imgproc
import org.tensorflow.lite.Interpreter
import java.io.File
import java.nio.ByteBuffer
import java.nio.ByteOrder

class ObjectDetector private constructor(private val interpreter: Interpreter) {
    private val inputSize = 300 // TensorFlow Modell EingabegrÃ¶ÃŸe
    private var lastDetection: Point? = null
    
    @Suppress("UNCHECKED_CAST")
    private val outputMap: MutableMap<Int, Any> = HashMap<Int, Any>().apply {
        this[0] = Array(1) { FloatArray(4) } // Bounding Box
        this[1] = Array(1) { FloatArray(1) } // Konfidenz
    }
    
    companion object {
        private const val TAG = "ObjectDetector"
        fun create(context: Context, modelPath: String): ObjectDetector {
            val modelFile = File(context.getExternalFilesDir(null), modelPath)
            val interpreter = Interpreter(modelFile)
            return ObjectDetector(interpreter)
        }
    }
    
    fun detectBall(frame: Mat): Point? {
        val processedFrame = preprocessFrame(frame)
        val inputBuffer = convertBitmapToByteBuffer(processedFrame)
        
        interpreter.runForMultipleInputsOutputs(arrayOf(inputBuffer), outputMap)
        
        val boundingBox = (outputMap[0] as? Array<*>)?.firstOrNull() as? FloatArray
        val confidence = (outputMap[1] as? Array<*>)?.firstOrNull() as? FloatArray

        if (boundingBox == null || confidence == null) {
            Log.e(TAG, "Fehler beim Casting der Detector-Ausgabe")
            return lastDetection
        }
        
        return if (confidence[0] > 0.7f) {
            Point(
                boundingBox[0].toDouble() * frame.cols(),
                boundingBox[1].toDouble() * frame.rows()
            ).also { lastDetection = it }
        } else {
            lastDetection
        }
    }
    
    private fun preprocessFrame(frame: Mat): Bitmap {
        val resized = Mat()
        Imgproc.resize(frame, resized, Size(inputSize.toDouble(), inputSize.toDouble()))
        
        val bitmap = Bitmap.createBitmap(inputSize, inputSize, Bitmap.Config.ARGB_8888)
        Utils.matToBitmap(resized, bitmap)
        return bitmap
    }
    
    private fun convertBitmapToByteBuffer(bitmap: Bitmap): ByteBuffer {
        val byteBuffer = ByteBuffer.allocateDirect(
            4 * inputSize * inputSize * 3
        ).apply {
            order(ByteOrder.nativeOrder())
        }
        
        val intValues = IntArray(inputSize * inputSize)
        bitmap.getPixels(intValues, 0, bitmap.width, 0, 0, bitmap.width, bitmap.height)
        
        for (pixelValue in intValues) {
            byteBuffer.putFloat((pixelValue shr 16 and 0xFF) / 255f)
            byteBuffer.putFloat((pixelValue shr 8 and 0xFF) / 255f)
            byteBuffer.putFloat((pixelValue and 0xFF) / 255f)
        }
        
        return byteBuffer
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\di\AppModule.kt
==========================================

package com.roulette.tracker.di

import android.content.Context
import com.roulette.tracker.data.BallTracker
import com.roulette.tracker.data.WheelTracker
import com.roulette.tracker.camera.CameraManager
import com.roulette.tracker.camera.FrameAnalyzer
import com.roulette.tracker.camera.OpenCVLoader
import com.roulette.tracker.PredictionEngine
import com.roulette.tracker.ocr.OCRService
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton
import androidx.work.WorkManager
import javax.inject.Provider
import androidx.hilt.work.HiltWorkerFactory
import androidx.hilt.work.WorkerFactory
import com.roulette.tracker.SettingsManager

@Module
@InstallIn(SingletonComponent::class)
object AppModule {
    
    @Provides
    @Singleton
    fun provideBallTracker(@ApplicationContext context: Context): BallTracker {
        return BallTracker(context)
    }
    
    @Provides
    @Singleton
    fun provideWheelTracker(@ApplicationContext context: Context): WheelTracker {
        return WheelTracker(context)
    }
    
    @Provides
    @Singleton
    fun providePredictionEngine(@ApplicationContext context: Context): PredictionEngine {
        return PredictionEngine(context)
    }
    
    @Provides
    @Singleton
    fun provideOpenCVLoader(): OpenCVLoader {
        return OpenCVLoader()
    }
    
    @Provides
    @Singleton
    fun provideCameraManager(
        @ApplicationContext context: Context,
        openCVLoader: OpenCVLoader
    ): CameraManager {
        return CameraManager(context, openCVLoader)
    }
    
    @Provides
    @Singleton
    fun provideFrameAnalyzer(): FrameAnalyzer {
        return FrameAnalyzer()
    }
    
    @Provides
    @Singleton
    fun provideOCRService(@ApplicationContext context: Context): OCRService {
        return OCRService(context)
    }

    @Provides
    @Singleton
    fun provideWorkManager(@ApplicationContext context: Context): WorkManager {
        return WorkManager.getInstance(context)
    }

    @Provides
    @Singleton
    fun provideHiltWorkerFactory(
        workerFactoryProvider: Provider<HiltWorkerFactory>
    ): WorkerFactory {
        return workerFactoryProvider.get()
    }

    @Provides
    @Singleton
    fun provideContext(@ApplicationContext context: Context): Context = context

    @Provides
    @Singleton
    fun provideSettingsManager(
        @ApplicationContext context: Context
    ): SettingsManager {
        return SettingsManager(context)
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\di\CameraModule.kt
==========================================

package com.roulette.tracker.di

import com.roulette.tracker.camera.FrameAnalyzerConfig
import com.roulette.tracker.ui.tracking.FrameProviderConfig
import com.roulette.tracker.ui.tracking.CameraLifecycleManager
import com.roulette.tracker.camera.CameraErrorHandler
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object CameraModule {
    
    @Provides
    @Singleton
    fun provideFrameProviderConfig(): FrameProviderConfig {
        return FrameProviderConfig(
            frameRate = 30,
            resolution = FrameProviderConfig.Resolution.HD,
            useHardwareAcceleration = true
        )
    }

    @Provides
    @Singleton
    fun provideFrameAnalyzerConfig(): FrameAnalyzerConfig {
        return FrameAnalyzerConfig(
            targetFps = 30,
            colorConversion = FrameAnalyzerConfig.ColorConversion.YUV2BGR
        )
    }

    @Provides
    @Singleton
    fun provideCameraLifecycleManager(): CameraLifecycleManager {
        return CameraLifecycleManager()
    }

    @Provides
    @Singleton
    fun provideCameraErrorHandler(): CameraErrorHandler {
        return CameraErrorHandler()
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\di\DatabaseModule.kt
==========================================

package com.roulette.tracker.di

import android.content.Context
import androidx.room.Room
import com.roulette.tracker.data.AppDatabase
import com.roulette.tracker.data.dao.SimulationDao
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
class DatabaseModule {
    
    @Provides
    @Singleton
    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {
        return Room.databaseBuilder(
            context,
            AppDatabase::class.java,
            "roulette_database"
        ).fallbackToDestructiveMigration()
         .build()
    }

    @Provides
    @Singleton
    fun provideSimulationDao(database: AppDatabase): SimulationDao {
        return database.simulationDao()
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\di\FrameModule.kt
==========================================

package com.roulette.tracker.di

import com.roulette.tracker.ui.tracking.FrameProvider
import com.roulette.tracker.ui.tracking.CameraFrameProvider
import com.roulette.tracker.ui.tracking.TestFrameProvider
import dagger.Binds
import dagger.Module
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import javax.inject.Qualifier
import javax.inject.Singleton
import dagger.Provides

@Qualifier
@Retention(AnnotationRetention.BINARY)
annotation class TestProvider

@Qualifier
@Retention(AnnotationRetention.BINARY)
annotation class CameraProviderImpl

@Module
@InstallIn(SingletonComponent::class)
abstract class FrameModule {
    
    @Binds
    @Singleton
    @CameraProviderImpl
    abstract fun bindCameraFrameProvider(
        cameraFrameProvider: CameraFrameProvider
    ): FrameProvider

    @Binds
    @Singleton
    @TestProvider
    abstract fun bindTestFrameProvider(
        testFrameProvider: TestFrameProvider
    ): FrameProvider

    companion object {
        @Provides
        @Singleton
        fun provideDefaultFrameProvider(
            @CameraProviderImpl cameraProvider: FrameProvider
        ): FrameProvider = cameraProvider
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\di\RepositoryModule.kt
==========================================

package com.roulette.tracker.di

import com.roulette.tracker.data.repository.Repository
import com.roulette.tracker.data.repository.SimulationRepository
import com.roulette.tracker.data.entities.SimulationResult
import dagger.Binds
import dagger.Module
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
abstract class RepositoryModule {
    @Binds
    @Singleton
    abstract fun bindSimulationRepository(
        repository: SimulationRepository
    ): Repository<SimulationResult>
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\di\UtilsModule.kt
==========================================

package com.roulette.tracker.di

import android.content.Context
import com.roulette.tracker.tracking.TrackingStateManager
import com.roulette.tracker.utils.ErrorHandler
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object UtilsModule {
    
    @Provides
    @Singleton
    fun provideTrackingStateManager(): TrackingStateManager {
        return TrackingStateManager()
    }
    
    @Provides
    @Singleton
    fun provideErrorHandler(
        @ApplicationContext context: Context
    ): ErrorHandler {
        return ErrorHandler(context)
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\ml\MLModel.kt
==========================================

package com.roulette.tracker.ml

import android.content.Context
import org.tensorflow.lite.Interpreter
import java.io.File
import java.nio.ByteBuffer
import java.nio.ByteOrder
import org.opencv.core.Point
import timber.log.Timber

class MLModel private constructor(private val interpreter: Interpreter) {
    private val modelFile = "roulette_model.tflite"
    private val inputSize = 5  // Ball x,y, velocity, wheel angle, wheel speed
    
    fun predict(
        ballPosition: Point,
        ballVelocity: Float,
        wheelAngle: Double,
        wheelSpeed: Double
    ): Pair<Int, Float> {
        val inputBuffer = createInputBuffer(
            ballPosition,
            ballVelocity,
            wheelAngle,
            wheelSpeed
        )

        val outputArray = FloatArray(OUTPUT_SIZE)
        val outputBuffer = ByteBuffer.allocateDirect(OUTPUT_SIZE * FLOAT_BYTES)
            .order(ByteOrder.nativeOrder())
            .asFloatBuffer()

        interpreter.run(inputBuffer, outputBuffer)
        outputBuffer[outputArray]  // Indexed accessor statt get()

        // Finde Maximum mit indexbasiertem Zugriff
        var maxProb = outputArray[0]
        var predictedNumber = 0
        
        for (i in 1..MAX_NUMBER) {
            if (outputArray[i] > maxProb) {
                maxProb = outputArray[i]
                predictedNumber = i
            }
        }

        return Pair(predictedNumber, maxProb * CONFIDENCE_SCALE)
    }

    private fun createInputBuffer(
        ballPosition: Point,
        ballVelocity: Float,
        wheelAngle: Double,
        wheelSpeed: Double
    ): FloatBuffer {
        return ByteBuffer.allocateDirect(inputSize * FLOAT_BYTES)
            .order(ByteOrder.nativeOrder())
            .asFloatBuffer()
            .apply {
                put(0, ballPosition.x.toFloat())
                put(1, ballPosition.y.toFloat())
                put(2, ballVelocity)
                put(3, wheelAngle.toFloat())
                put(4, wheelSpeed.toFloat())
            }
    }

    fun release() {
        try {
            interpreter.close()
        } catch (e: Exception) {
            Timber.e(e, "Fehler beim SchlieÃŸen des Interpreters")
        }
    }

    companion object {
        private const val FLOAT_BYTES = 4
        private const val OUTPUT_SIZE = 38  // 37 numbers + 1 confidence
        private const val MAX_NUMBER = 36
        private const val CONFIDENCE_SCALE = 100f

        fun create(modelFile: File): MLModel? {
            return try {
                val interpreter = Interpreter(modelFile)
                MLModel(interpreter)
            } catch (e: Exception) {
                Timber.e(e, "Fehler beim Erstellen des MLModels")
                null
            }
        }
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\network\RtspClient.kt
==========================================

package com.roulette.tracker.network

import android.util.Log
import android.view.SurfaceView
import org.opencv.core.Mat
import com.roulette.tracker.utils.FrameExtractor
import kotlinx.coroutines.*

class RtspClient(
    private val url: String,
    private val surfaceView: SurfaceView,
    private val onFrameReceived: (Mat) -> Unit
) {
    private var isRunning = false
    private val scope = CoroutineScope(Dispatchers.IO + Job())
    private val frameExtractor = FrameExtractor()
    
    fun start() {
        isRunning = true
        scope.launch {
            try {
                // FÃ¼r den Test: Extrahiere einfach Frames vom SurfaceView
                while (isRunning) {
                    frameExtractor.extractFrame(surfaceView)?.let { frame ->
                        onFrameReceived(frame)
                    }
                    delay(33) // ca. 30 FPS
                }
            } catch (e: Exception) {
                Log.e("RtspClient", "Streaming-Fehler: ${e.message}")
            }
        }
    }
    
    fun stop() {
        isRunning = false
        scope.cancel()
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\ocr\OCRService.kt
==========================================

package com.roulette.tracker.ocr

import android.content.Context
import android.graphics.Bitmap
import android.util.Log
import com.adaptech.tesseract4android.TessBaseAPI
import org.opencv.android.Utils
import org.opencv.core.Mat
import org.opencv.core.Size
import org.opencv.imgproc.Imgproc
import javax.inject.Inject
import javax.inject.Singleton
import java.io.File
import java.io.FileOutputStream
import java.io.IOException
import android.util.LruCache
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import java.util.ArrayDeque
import org.opencv.core.Scalar

@Singleton
class OCRService @Inject constructor(
    private val context: Context,
    private val coroutineScope: CoroutineScope = CoroutineScope(Dispatchers.Default)
) {
    private var tesseract: TessBaseAPI? = null
    private val TAG = "OCRService"
    private val numberCache = LruCache<Int, List<Int>>(20)
    private val matPool = MatPool(5) // Objekt-Pool fÃ¼r Mat-Objekte
    
    private class MatPool(capacity: Int) {
        private val pool = ArrayDeque<Mat>(capacity)
        
        @Synchronized
        fun acquire(): Mat = pool.removeFirstOrNull() ?: Mat()
        
        @Synchronized
        fun release(mat: Mat) {
            if (pool.size < capacity && !mat.empty()) {
                mat.setTo(Scalar(0.0))
                pool.addLast(mat)
            } else {
                mat.release()
            }
        }
        
        fun clear() {
            pool.forEach { it.release() }
            pool.clear()
        }
    }

    init {
        initTesseract()
    }

    private fun initTesseract() {
        try {
            val dataPath = File(context.getExternalFilesDir(null), "tessdata")
            if (!dataPath.exists()) {
                dataPath.mkdirs()
                copyTrainedData(dataPath)
            }

            tesseract = TessBaseAPI().apply {
                init(dataPath.parent, "eng", TessBaseAPI.OEM_LSTM_ONLY)
                setVariable(TessBaseAPI.VAR_CHAR_WHITELIST, "0123456789")
                setVariable(TessBaseAPI.VAR_CHAR_BLACKLIST, "!@#$%^&*()_+=-[]{}|;:,.<>?/abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")
                setVariable("tessedit_pageseg_mode", "7") // Treat image as single text line
                setVariable("tessedit_ocr_engine_mode", "3") // Use LSTM OCR Engine
                setVariable("load_system_dawg", "0") // Disable dictionary
                setVariable("load_freq_dawg", "0")
                setVariable("textord_heavy_nr", "1") // Better handling of numeric recognition
                setVariable("tessedit_minimal_confidence", "60") // Minimum confidence threshold
                setPageSegMode(TessBaseAPI.PageSegMode.PSM_SINGLE_LINE)
            }
        } catch (e: Exception) {
            Log.e(TAG, "Fehler bei Tesseract-Initialisierung", e)
        }
    }

    fun recognizeNumbers(mat: Mat): List<Int> {
        var processed = matPool.acquire()
        var kernel = matPool.acquire()
        var bitmap: Bitmap? = null
        
        return try {
            preprocessImage(mat, processed)
            
            // Verbessertes morphologisches Closing
            Imgproc.morphologyEx(processed, processed, Imgproc.MORPH_CLOSE, kernel)
            
            // KantenglÃ¤ttung
            Imgproc.medianBlur(processed, processed, 3)
            
            bitmap = Bitmap.createBitmap(processed.cols(), processed.rows(), Bitmap.Config.ARGB_8888)
            Utils.matToBitmap(processed, bitmap)
            
            recognizeNumbers(bitmap)
        } catch (e: Exception) {
            Log.e(TAG, "Fehler bei der Bildverarbeitung", e)
            emptyList()
        } finally {
            matPool.release(processed)
            matPool.release(kernel)
            bitmap?.recycle()
        }
    }

    fun recognizeNumbers(bitmap: Bitmap): List<Int> {
        val cacheKey = bitmap.generateHash()
        
        numberCache.get(cacheKey)?.let { cached ->
            return cached
        }
        
        return tesseract?.let { tess ->
            try {
                tess.setImage(bitmap)
                val numbers = tess.utF8Text?.split("\n")
                    ?.mapNotNull { it.trim().toIntOrNull() }
                    ?.let { validateNumbers(it) }
                    ?: emptyList()
                    
                if (numbers.isNotEmpty()) {
                    numberCache.put(cacheKey, numbers)
                }
                numbers
            } catch (e: Exception) {
                Log.e(TAG, "Fehler bei der Zahlenerkennung", e)
                emptyList()
            }
        } ?: emptyList()
    }

    private fun copyTrainedData(dataPath: File) {
        try {
            context.assets.open("tessdata/eng.traineddata").use { input ->
                FileOutputStream(File(dataPath, "eng.traineddata")).use { output ->
                    input.copyTo(output)
                }
            }
        } catch (e: IOException) {
            Log.e(TAG, "Fehler beim Kopieren der Trainingsdaten", e)
        }
    }

    fun release() {
        tesseract?.end()
        tesseract = null
        matPool.clear()
        numberCache.evictAll()
    }

    private fun Bitmap.generateHash(): Int {
        // Einfacher Hash fÃ¼r Bitmap-Inhalt
        val pixels = IntArray(width * height)
        getPixels(pixels, 0, width, 0, 0, width, height)
        return pixels.contentHashCode()
    }

    private fun preprocessImage(mat: Mat, processed: Mat) {
        // BildgrÃ¶ÃŸe optimieren basierend auf DPI
        val dpi = context.resources.displayMetrics.densityDpi
        val scaleFactor = (300.0 / dpi).coerceIn(1.0, 3.0)
        val targetSize = Size(mat.width() * scaleFactor, mat.height() * scaleFactor)
        
        Imgproc.resize(mat, processed, targetSize, 0.0, 0.0, Imgproc.INTER_CUBIC)
        
        // Verbesserte Vorverarbeitung
        Imgproc.cvtColor(processed, processed, Imgproc.COLOR_BGR2GRAY)
        
        // Rauschreduzierung mit bilateralem Filter fÃ¼r bessere Kantenerkennung
        Imgproc.bilateralFilter(processed, processed, 9, 75.0, 75.0)
        
        // Lokale KontrastverstÃ¤rkung mit optimierten Parametern
        val clahe = Imgproc.createCLAHE(3.0, Size(8.0, 8.0))
        clahe.apply(processed, processed)
        
        // Adaptive Schwellenwert-Segmentierung mit optimierten Parametern
        Imgproc.adaptiveThreshold(
            processed, processed,
            255.0,
            Imgproc.ADAPTIVE_THRESH_GAUSSIAN_C,
            Imgproc.THRESH_BINARY,
            15, 5.0
        )
    }

    private fun validateNumbers(numbers: List<Int>): List<Int> {
        if (numbers.isEmpty()) return emptyList()
        
        // PrÃ¼fe auf ungÃ¼ltige Zahlenkombinationen
        val validNumbers = numbers.filter { it in 0..36 }
        
        // PrÃ¼fe auf Duplikate und unwahrscheinliche Sequenzen
        return validNumbers
            .distinct()
            .filterNot { number ->
                val neighbors = validNumbers.filter { 
                    abs(it - number) <= 1 || abs(it - number) == 35 
                }
                neighbors.size > 2 // Unwahrscheinlich viele benachbarte Zahlen
            }
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\settings\SettingsManager.kt
==========================================

@Singleton
class SettingsManager @Inject constructor(
    @ApplicationContext private val context: Context
) {
    private val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)

    var confidenceThreshold: Float
        get() = prefs.getFloat(KEY_CONFIDENCE_THRESHOLD, DEFAULT_CONFIDENCE_THRESHOLD)
        set(value) = prefs.edit().putFloat(KEY_CONFIDENCE_THRESHOLD, value).apply()

    var predictionDelay: Int
        get() = prefs.getInt(KEY_PREDICTION_DELAY, DEFAULT_PREDICTION_DELAY)
        set(value) = prefs.edit().putInt(KEY_PREDICTION_DELAY, value).apply()

    var debugMode: Boolean
        get() = prefs.getBoolean(KEY_DEBUG_MODE, DEFAULT_DEBUG_MODE)
        set(value) = prefs.edit().putBoolean(KEY_DEBUG_MODE, value).apply()

    companion object {
        private const val PREFS_NAME = "roulette_tracker_settings"
        private const val KEY_CONFIDENCE_THRESHOLD = "confidence_threshold"
        private const val KEY_PREDICTION_DELAY = "prediction_delay"
        private const val KEY_DEBUG_MODE = "debug_mode"
        
        private const val DEFAULT_CONFIDENCE_THRESHOLD = 0.7f
        private const val DEFAULT_PREDICTION_DELAY = 2
        private const val DEFAULT_DEBUG_MODE = false
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\tracking\BallTracker.kt
==========================================

@file:OptIn(ExperimentalUnsignedTypes::class)
package com.roulette.tracker

import android.content.Context
import org.opencv.core.*
import org.opencv.imgproc.Imgproc
import com.roulette.tracker.data.BallData
import javax.inject.Inject

class BallTracker @Inject constructor(private val context: Context) {
    private var lastPosition: Point? = null
    private var lastTimestamp: Long = 0

    fun trackBall(frame: Mat): BallData? {
        // Bild in HSV-Farbraum konvertieren
        val hsvFrame = Mat()
        Imgproc.cvtColor(frame, hsvFrame, Imgproc.COLOR_BGR2HSV)

        // WeiÃŸen Ball erkennen
        val ballMask = Mat()
        Core.inRange(
            hsvFrame,
            Scalar(0.0, 0.0, 200.0),  // Untere Grenze fÃ¼r WeiÃŸ
            Scalar(180.0, 30.0, 255.0),  // Obere Grenze fÃ¼r WeiÃŸ
            ballMask
        )

        // Rauschen reduzieren
        Imgproc.erode(ballMask, ballMask, Imgproc.getStructuringElement(Imgproc.MORPH_ELLIPSE, Size(5.0, 5.0)))
        Imgproc.dilate(ballMask, ballMask, Imgproc.getStructuringElement(Imgproc.MORPH_ELLIPSE, Size(5.0, 5.0)))

        // Konturen finden
        val contours = ArrayList<MatOfPoint>()
        Imgproc.findContours(ballMask, contours, Mat(), Imgproc.RETR_EXTERNAL, Imgproc.CHAIN_APPROX_SIMPLE)

        // GrÃ¶ÃŸte runde Kontur finden
        val ballPosition = findBallPosition(frame) ?: return null
        
        // Geschwindigkeit berechnen
        val currentTime = System.currentTimeMillis()
        val velocity = calculateVelocity(ballPosition)
        
        // Landezeitpunkt vorhersagen
        val predictedLandingTime = predictLandingTime(ballPosition, velocity)

        lastPosition = ballPosition
        lastTimestamp = currentTime

        return BallData(
            currentPosition = ballPosition,
            velocity = velocity,
            predictedLandingTime = predictedLandingTime
        )
    }

    private fun findBallPosition(frame: Mat): Point? {
        var bestCircle: Point? = null
        var maxCircularity = 0.0

        val contours = ArrayList<MatOfPoint>()
        Imgproc.findContours(frame, contours, Mat(), Imgproc.RETR_EXTERNAL, Imgproc.CHAIN_APPROX_SIMPLE)

        for (contour in contours) {
            val area = Imgproc.contourArea(contour)
            if (area < 100) continue  // Zu kleine Konturen ignorieren

            val perimeter = Imgproc.arcLength(MatOfPoint2f(*contour.toArray()), true)
            val circularity = 4 * Math.PI * area / (perimeter * perimeter)

            if (circularity > 0.8 && circularity > maxCircularity) {  // Nur sehr runde Objekte
                val moments = Imgproc.moments(contour)
                val center = Point(moments.m10 / moments.m00, moments.m01 / moments.m00)
                bestCircle = center
                maxCircularity = circularity
            }
        }

        return bestCircle
    }

    private fun calculateVelocity(currentPosition: Point): Double {
        if (currentPosition == null || lastPosition == null || lastTimestamp == 0L) return 0.0

        val deltaTime = (System.currentTimeMillis() - lastTimestamp) / 1000.0  // in Sekunden
        if (deltaTime == 0.0) return 0.0

        val distance = Math.sqrt(
            Math.pow(currentPosition.x - lastPosition!!.x, 2.0) +
            Math.pow(currentPosition.y - lastPosition!!.y, 2.0)
        )

        return distance / deltaTime
    }

    private fun predictLandingTime(position: Point, velocity: Double): Long {
        // Einfache lineare Vorhersage - kann spÃ¤ter verfeinert werden
        if (position == null || velocity == 0.0) return 0L

        // Annahme: Ball landet am unteren Rand des Roulette-Rads
        val distanceToLanding = 500.0  // Beispielwert, muss angepasst werden
        val timeToLanding = (distanceToLanding / velocity).toLong()

        return System.currentTimeMillis() + timeToLanding
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\tracking\TrackingStateManager.kt
==========================================

package com.roulette.tracker.tracking

import com.roulette.tracker.data.TrackingState
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class TrackingStateManager @Inject constructor() {
    private val _trackingState = MutableStateFlow<TrackingState>(TrackingState.INITIALIZING)
    val trackingState: StateFlow<TrackingState> = _trackingState.asStateFlow()

    private val _predictionResults = MutableStateFlow<List<PredictionResult>>(emptyList())
    val predictionResults: StateFlow<List<PredictionResult>> = _predictionResults.asStateFlow()

    fun updateState(newState: TrackingState, message: String? = null) {
        _trackingState.value = newState.apply { 
            this.message = message 
        }
    }

    fun addPredictionResult(result: PredictionResult) {
        _predictionResults.update { current ->
            current.take(9) + result
        }
    }

    fun reset() {
        _trackingState.value = TrackingState.INITIALIZING
        _predictionResults.value = emptyList()
    }

    fun reportError(message: String) {
        _trackingState.value = TrackingState.Error(message)
    }

    fun startTracking() {
        _trackingState.value = TrackingState.Running
    }

    fun ballLost() {
        _trackingState.value = TrackingState.BallNotFound
    }

    fun wheelLost() {
        _trackingState.value = TrackingState.WheelNotFound
    }

    fun startPrediction(timeRemaining: Long) {
        _trackingState.value = TrackingState.Predicting(timeRemaining)
    }

    fun predictionComplete(result: com.roulette.tracker.data.PredictionResult) {
        _trackingState.value = TrackingState.Success(result)
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\tracking\WheelTracker.kt
==========================================

@file:OptIn(ExperimentalUnsignedTypes::class)
package com.roulette.tracker

import android.content.Context
import android.util.Log
import org.opencv.core.*
import org.opencv.imgproc.Imgproc
import com.roulette.tracker.data.WheelData
import javax.inject.Inject

class WheelTracker @Inject constructor(
    private val context: Context,
    private val ocrService: OCRService
) {
    private var lastAngle: Double = 0.0
    private var lastTimestamp: Long = 0

    fun trackWheel(frame: Mat): WheelData {
        // Bild in Graustufen konvertieren
        val gray = Mat()
        Imgproc.cvtColor(frame, gray, Imgproc.COLOR_BGR2GRAY)
        
        // Rauschen reduzieren
        Imgproc.GaussianBlur(gray, gray, Size(5.0, 5.0), 0.0)
        
        // Kreise erkennen (Hough Transform)
        val circles = Mat()
        Imgproc.HoughCircles(
            gray,
            circles,
            Imgproc.HOUGH_GRADIENT,
            1.0,
            gray.rows() / 8.0,
            100.0,
            30.0,
            gray.rows() / 8,
            gray.rows() / 3
        )

        if (circles.cols() > 0) {
            val wheelCircle = circles.get(0, 0)
            val center = Point(wheelCircle[0], wheelCircle[1])
            val radius = wheelCircle[2]

            // ROI (Region of Interest) fÃ¼r das Rad erstellen
            val roi = extractROI(frame, center, radius)
            
            // Winkel des Rads berechnen
            val currentAngle = detectWheelAngle(roi)
            
            // Rotationsgeschwindigkeit berechnen
            val currentTime = System.currentTimeMillis()
            val rotationSpeed = calculateRotationSpeed(currentAngle, currentTime)
            
            // Sichtbare Zahlen erkennen
            val visibleNumbers = detectVisibleNumbers(roi)

            lastAngle = currentAngle
            lastTimestamp = currentTime

            return WheelData(
                currentAngle = currentAngle,
                rotationSpeed = rotationSpeed,
                visibleNumbers = visibleNumbers
            )
        }

        return WheelData(
            currentAngle = 0.0,
            rotationSpeed = 0.0,
            visibleNumbers = emptyList()
        )
    }

    private fun extractROI(frame: Mat, center: Point, radius: Double): Mat {
        val roi = Mat()
        try {
            val rect = Rect(
                (center.x - radius).toInt(),
                (center.y - radius).toInt(),
                (2 * radius).toInt(),
                (2 * radius).toInt()
            )
            
            // Sicherstellen, dass ROI innerhalb der Bildgrenzen liegt
            val safeRect = Rect(
                rect.x.coerceIn(0, frame.cols() - 1),
                rect.y.coerceIn(0, frame.rows() - 1),
                rect.width.coerceAtMost(frame.cols() - rect.x),
                rect.height.coerceAtMost(frame.rows() - rect.y)
            )
            
            if (safeRect.width > 0 && safeRect.height > 0) {
                frame.submat(safeRect).copyTo(roi)
            } else {
                Log.w(TAG, "UngÃ¼ltige ROI-Dimensionen")
                frame.copyTo(roi)
            }
        } catch (e: Exception) {
            Log.e(TAG, "Fehler bei ROI-Extraktion", e)
            frame.copyTo(roi)
        }
        return roi
    }

    private fun detectWheelAngle(roi: Mat): Double {
        // Kanten erkennen
        val edges = Mat()
        Imgproc.Canny(roi, edges, 50.0, 150.0)
        
        // Linien erkennen
        val lines = Mat()
        Imgproc.HoughLines(edges, lines, 1.0, Math.PI / 180, 100)
        
        // Dominanten Winkel finden
        var dominantAngle = 0.0
        if (lines.rows() > 0) {
            val line = lines.get(0, 0)
            dominantAngle = Math.toDegrees(line[1])
        }
        
        return dominantAngle
    }

    private fun calculateRotationSpeed(currentAngle: Double, currentTime: Long): Double {
        if (lastTimestamp == 0L) return 0.0
        
        val deltaTime = (currentTime - lastTimestamp) / 1000.0  // in Sekunden
        if (deltaTime == 0.0) return 0.0
        
        var deltaAngle = currentAngle - lastAngle
        
        // Korrektur fÃ¼r WinkelÃ¼bergÃ¤nge
        if (deltaAngle > 180) deltaAngle -= 360
        if (deltaAngle < -180) deltaAngle += 360
        
        return deltaAngle / deltaTime
    }

    private fun detectVisibleNumbers(roi: Mat): List<Int> {
        // Vorverarbeitung fÃ¼r bessere OCR-Ergebnisse
        val processedRoi = Mat()
        
        // Bild fÃ¼r OCR optimieren
        Imgproc.threshold(roi, processedRoi, 0.0, 255.0, Imgproc.THRESH_BINARY + Imgproc.THRESH_OTSU)
        
        // Text-Regionen finden und extrahieren
        val textRegions = findTextRegions(processedRoi)
        
        // OCR auf jede Region anwenden und Zahlen extrahieren
        return textRegions.mapNotNull { region ->
            try {
                val number = ocrService.recognizeNumber(region)
                if (number in 0..36) number else null
            } catch (e: Exception) {
                Log.e(TAG, "Fehler bei OCR-Erkennung", e)
                null
            }
        }
    }

    private fun findTextRegions(image: Mat): List<Mat> {
        val regions = mutableListOf<Mat>()
        
        // MSER (Maximally Stable Extremal Regions) fÃ¼r Texterkennung
        val mser = MSER.create()
        val msers = MatOfRect()
        
        mser.detectRegions(image, msers)
        
        // Regionen extrahieren und filtern
        msers.toArray().forEach { rect ->
            if (isValidTextRegion(rect)) {
                regions.add(image.submat(rect))
            }
        }
        
        return regions
    }

    private fun isValidTextRegion(rect: Rect): Boolean {
        // Filterkriterien fÃ¼r Textregionen
        val aspectRatio = rect.width.toDouble() / rect.height
        val area = rect.width * rect.height
        
        return aspectRatio in 0.2..2.0 && // Typische AspektverhÃ¤ltnisse fÃ¼r Zahlen
               area in 100..1000 // Minimale/maximale GrÃ¶ÃŸe fÃ¼r lesbare Zahlen
    }

    fun release() {
        try {
            // AufrÃ¤umen der OpenCV-Ressourcen
            lastAngle = 0.0
            lastTimestamp = 0L
        } catch (e: Exception) {
            Log.e(TAG, "Fehler beim AufrÃ¤umen der Ressourcen", e)
        }
    }

    override fun finalize() {
        release()
    }

    companion object {
        private const val TAG = "WheelTracker"
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\ui\LiveTrackingViewModel.kt
==========================================

package com.roulette.tracker.ui

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import androidx.lifecycle.asLiveData
import com.roulette.tracker.data.*
import com.roulette.tracker.data.entities.SimulationResult
import com.roulette.tracker.data.repository.SimulationRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class LiveTrackingViewModel @Inject constructor(
    private val repository: SimulationRepository
) : ViewModel() {
    
    val allResults = repository.allResults.asLiveData()
    val accuracyRate = repository.accuracyRate.asLiveData()

    fun saveResult(result: AnalysisResult) {
        viewModelScope.launch {
            result.prediction?.let { prediction ->
                val simulationResult = SimulationResult(
                    timestamp = System.currentTimeMillis(),
                    predictedNumber = prediction.predictedNumber,
                    actualNumber = null  // Wird spÃ¤ter Ã¼ber updateActualNumber gesetzt
                )
                repository.insertResult(simulationResult)
            }
        }
    }

    fun updateActualNumber(resultId: Long, actualNumber: Int) {
        viewModelScope.launch {
            repository.updateActualNumber(resultId, actualNumber)
        }
    }
    
    fun clearAllResults() {
        viewModelScope.launch {
            repository.deleteAll()
        }
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\ui\MainActivity.kt
==========================================

package com.roulette.tracker.ui

import android.os.Bundle
import android.util.Log
import androidx.appcompat.app.AppCompatActivity
import androidx.navigation.NavController
import androidx.navigation.fragment.NavHostFragment
import androidx.navigation.ui.setupWithNavController
import org.opencv.android.OpenCVLoader
import org.opencv.android.BaseLoaderCallback
import org.opencv.android.LoaderCallbackInterface
import com.roulette.tracker.databinding.ActivityMainBinding
import com.roulette.tracker.R
import dagger.hilt.android.AndroidEntryPoint
import androidx.core.app.ActivityCompat
import android.Manifest
import android.content.pm.PackageManager
import android.content.Context
import androidx.core.content.ContextCompat
import android.os.Build
import android.app.AlertDialog
import android.widget.Toast

@AndroidEntryPoint
class MainActivity : AppCompatActivity() {
    private lateinit var binding: ActivityMainBinding
    private lateinit var navController: NavController
    
    private val loaderCallback = object : BaseLoaderCallback(this) {
        override fun onManagerConnected(status: Int) {
            when (status) {
                LoaderCallbackInterface.SUCCESS -> {
                    Log.i("OpenCV", "OpenCV geladen")
                }
                else -> {
                    super.onManagerConnected(status)
                }
            }
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)
        
        setSupportActionBar(binding.toolbar)
        
        val navHostFragment = supportFragmentManager
            .findFragmentById(R.id.nav_host_fragment) as NavHostFragment
        navController = navHostFragment.navController
        
        binding.bottomNavigation.setupWithNavController(navController)
        
        checkPermissions()
    }

    override fun onResume() {
        super.onResume()
        if (hasRequiredPermissions()) {
            initializeOpenCV()
        }
    }

    private fun initializeOpenCV() {
        if (!OpenCVLoader.initDebug()) {
            Log.d("OpenCV", "Interner OpenCV Manager wird initialisiert")
            OpenCVLoader.initAsync(OpenCVLoader.OPENCV_VERSION, this, loaderCallback)
        } else {
            Log.d("OpenCV", "OpenCV wurde initialisiert")
            loaderCallback.onManagerConnected(LoaderCallbackInterface.SUCCESS)
        }
    }

    private fun checkPermissions() {
        if (!hasRequiredPermissions()) {
            if (shouldShowRequestPermissionRationale()) {
                showPermissionRationaleDialog()
            } else {
                requestPermissions()
            }
        }
    }

    private fun shouldShowRequestPermissionRationale(): Boolean {
        return REQUIRED_PERMISSIONS.any {
            ActivityCompat.shouldShowRequestPermissionRationale(this, it)
        }
    }

    private fun showPermissionRationaleDialog() {
        AlertDialog.Builder(this)
            .setTitle(R.string.permissions_required)
            .setMessage(R.string.permissions_explanation)
            .setPositiveButton(R.string.ok) { _, _ ->
                requestPermissions()
            }
            .setNegativeButton(R.string.cancel) { _, _ ->
                finish()
            }
            .show()
    }

    private fun requestPermissions() {
        ActivityCompat.requestPermissions(
            this,
            REQUIRED_PERMISSIONS,
            REQUEST_CODE_PERMISSIONS
        )
    }

    override fun onRequestPermissionsResult(
        requestCode: Int,
        permissions: Array<String>,
        grantResults: IntArray
    ) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
        if (requestCode == REQUEST_CODE_PERMISSIONS && !hasRequiredPermissions()) {
            if (shouldShowRequestPermissionRationale()) {
                showPermissionRationaleDialog()
            } else {
                Toast.makeText(
                    this,
                    R.string.permissions_required_error,
                    Toast.LENGTH_LONG
                ).show()
                finish()
            }
        } else {
            initializeOpenCV()
        }
    }

    companion object {
        private const val REQUEST_CODE_PERMISSIONS = 10
        private val REQUIRED_PERMISSIONS = arrayOf(
            Manifest.permission.CAMERA,
            *if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                arrayOf(
                    Manifest.permission.READ_MEDIA_IMAGES,
                    Manifest.permission.READ_MEDIA_VIDEO
                )
            } else {
                arrayOf(
                    Manifest.permission.READ_EXTERNAL_STORAGE,
                    Manifest.permission.WRITE_EXTERNAL_STORAGE
                )
            }
        )
    }

    private fun hasRequiredPermissions(): Boolean {
        return REQUIRED_PERMISSIONS.all {
            ContextCompat.checkSelfPermission(this, it) == PackageManager.PERMISSION_GRANTED
        }
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\ui\SettingsActivity.kt
==========================================

package com.roulette.tracker

import android.content.Context
import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import com.roulette.tracker.databinding.ActivitySettingsBinding
import dagger.hilt.android.AndroidEntryPoint

@AndroidEntryPoint
class SettingsActivity : AppCompatActivity() {
    private lateinit var binding: ActivitySettingsBinding
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivitySettingsBinding.inflate(layoutInflater)
        setContentView(binding.root)
        
        loadSettings()
    }
    
    private fun loadSettings() {
        // Lade gespeicherte Einstellungen
        val prefs = getSharedPreferences("settings", Context.MODE_PRIVATE)
        binding.wheelDiameter.setText(prefs.getString("wheelDiameter", ""))
        binding.ballDiameter.setText(prefs.getString("ballDiameter", ""))
        binding.numberSpacing.setText(prefs.getString("numberSpacing", ""))
        binding.minTrackingFrames.setText(prefs.getString("minTrackingFrames", ""))
        binding.predictionWindow.setText(prefs.getString("predictionWindow", ""))
    }
    
    override fun onPause() {
        super.onPause()
        // Speichere Einstellungen
        getSharedPreferences("settings", Context.MODE_PRIVATE).edit().apply {
            putString("wheelDiameter", binding.wheelDiameter.text.toString())
            putString("ballDiameter", binding.ballDiameter.text.toString())
            putString("numberSpacing", binding.numberSpacing.text.toString())
            putString("minTrackingFrames", binding.minTrackingFrames.text.toString())
            putString("predictionWindow", binding.predictionWindow.text.toString())
            apply()
        }
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\ui\StatisticsActivity.kt
==========================================

package com.roulette.tracker.ui

import android.os.Bundle
import androidx.activity.viewModels
import androidx.appcompat.app.AppCompatActivity
import com.github.mikephil.charting.components.XAxis
import com.github.mikephil.charting.data.Entry
import com.github.mikephil.charting.data.LineData
import com.github.mikephil.charting.data.LineDataSet
import com.roulette.tracker.databinding.ActivityStatisticsBinding
import dagger.hilt.android.AndroidEntryPoint
import android.graphics.Color
import java.text.DecimalFormat
import com.google.android.material.snackbar.Snackbar
import android.view.MenuItem
import android.widget.AdapterView
import android.widget.ArrayAdapter
import android.view.View

@AndroidEntryPoint
class StatisticsActivity : AppCompatActivity() {
    private lateinit var binding: ActivityStatisticsBinding
    private val viewModel: StatisticsViewModel by viewModels()
    private val decimalFormat = DecimalFormat("#.##")

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityStatisticsBinding.inflate(layoutInflater)
        setContentView(binding.root)

        setupToolbar()
        setupCharts()
        setupSwipeRefresh()
        setupTimeRangeSpinner()
        observeData()
    }

    private fun setupToolbar() {
        setSupportActionBar(binding.toolbar)
        supportActionBar?.apply {
            setDisplayHomeAsUpEnabled(true)
            title = "Statistiken"
        }
    }

    private fun setupSwipeRefresh() {
        binding.swipeRefresh.setOnRefreshListener {
            viewModel.refreshStatistics()
        }
    }

    private fun setupCharts() {
        with(binding.accuracyChart) {
            setHardwareAccelerationEnabled(true)
            setDrawGridBackground(false)
            setDrawBorders(false)
            
            isAutoScaleMinMaxEnabled = true
            setViewPortOffsets(50f, 20f, 20f, 50f)
            
            description.isEnabled = false
            legend.apply {
                isEnabled = true
                textSize = 12f
                formSize = 12f
            }
            
            xAxis.apply {
                position = XAxis.XAxisPosition.BOTTOM
                setDrawGridLines(false)
                granularity = 1f
            }
            
            axisLeft.apply {
                setDrawGridLines(true)
                axisMinimum = 0f
                axisMaximum = 100f
                setDrawZeroLine(true)
            }
            
            axisRight.isEnabled = false
        }

        with(binding.predictionChart) {
            description.isEnabled = false
            setTouchEnabled(true)
            isDragEnabled = true
            setScaleEnabled(true)
            setPinchZoom(true)
            
            xAxis.apply {
                position = XAxis.XAxisPosition.BOTTOM
                setDrawGridLines(false)
                granularity = 1f
            }
            
            axisLeft.apply {
                setDrawGridLines(true)
                axisMinimum = 0f
                axisMaximum = 36f
            }
            
            axisRight.isEnabled = false
            legend.isEnabled = true
        }
    }

    private fun setupTimeRangeSpinner() {
        val adapter = ArrayAdapter(
            this,
            android.R.layout.simple_spinner_item,
            StatisticsViewModel.TimeRange.values().map { 
                when(it) {
                    StatisticsViewModel.TimeRange.LAST_24H -> "Letzte 24 Stunden"
                    StatisticsViewModel.TimeRange.LAST_WEEK -> "Letzte Woche"
                    StatisticsViewModel.TimeRange.LAST_MONTH -> "Letzter Monat"
                    StatisticsViewModel.TimeRange.ALL -> "Alle Zeiten"
                }
            }
        ).apply {
            setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
        }

        binding.timeRangeSpinner.apply {
            this.adapter = adapter
            onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
                override fun onItemSelected(parent: AdapterView<*>?, view: View?, position: Int, id: Long) {
                    viewModel.setTimeRange(StatisticsViewModel.TimeRange.values()[position])
                }
                override fun onNothingSelected(parent: AdapterView<*>?) {
                    // Wenn nichts ausgewÃ¤hlt ist, Standard-Zeitraum verwenden
                    viewModel.setTimeRange(StatisticsViewModel.TimeRange.LAST_WEEK)
                    
                    // UI-Feedback
                    binding.swipeRefresh.isRefreshing = true
                    viewModel.refreshStatistics()
                }
            }
        }
    }

    private fun observeData() {
        viewModel.statisticsData.observe(this) { stats ->
            updateAccuracyChart(stats.accuracyData)
            updatePredictionChart(stats.predictionData)
            updateStatsSummary(stats)
            binding.swipeRefresh.isRefreshing = false
        }

        viewModel.isLoading.observe(this) { isLoading ->
            binding.swipeRefresh.isRefreshing = isLoading
        }

        viewModel.error.observe(this) { error ->
            error?.let { showError(it) }
        }
    }

    private fun showError(error: String) {
        Snackbar.make(binding.root, error, Snackbar.LENGTH_LONG)
            .setAction("Wiederholen") {
                viewModel.refreshStatistics()
            }
            .show()
    }

    private fun updateAccuracyChart(accuracyData: List<Float>) {
        val entries = accuracyData.mapIndexed { index, value ->
            Entry(index.toFloat(), value)
        }

        val dataSet = LineDataSet(entries, "Genauigkeit").apply {
            color = Color.BLUE
            setCircleColor(Color.BLUE)
            setDrawValues(false)
            lineWidth = 2f
            circleRadius = 4f
            mode = LineDataSet.Mode.CUBIC_BEZIER
            cubicIntensity = 0.2f
        }

        binding.accuracyChart.apply {
            data = LineData(dataSet)
            animateX(500)
            setVisibleXRangeMaximum(50f)
            moveViewToX(accuracyData.size.toFloat())
            invalidate()
        }
    }

    private fun updatePredictionChart(predictionData: List<Pair<Int, Int>>) {
        val predictedEntries = predictionData.mapIndexed { index, (predicted, _) ->
            Entry(index.toFloat(), predicted.toFloat())
        }
        val actualEntries = predictionData.mapIndexed { index, (_, actual) ->
            Entry(index.toFloat(), actual.toFloat())
        }

        val predictedDataSet = LineDataSet(predictedEntries, "Vorhergesagt").apply {
            color = Color.RED
            setCircleColor(Color.RED)
            setDrawValues(false)
            lineWidth = 2f
            circleRadius = 4f
        }
        
        val actualDataSet = LineDataSet(actualEntries, "TatsÃ¤chlich").apply {
            color = Color.GREEN
            setCircleColor(Color.GREEN)
            setDrawValues(false)
            lineWidth = 2f
            circleRadius = 4f
        }

        binding.predictionChart.data = LineData(predictedDataSet, actualDataSet)
        binding.predictionChart.invalidate()

        binding.predictionChart.apply {
            animateX(1000)
            setVisibleXRangeMaximum(20f)
            moveViewToX(predictionData.size.toFloat())
        }
    }

    private fun updateStatsSummary(stats: StatisticsData) {
        binding.stats100.text = """
            Letzte 100 Vorhersagen:
            â€¢ Korrekte Vorhersagen: ${stats.last100Stats.correctPredictions}/${stats.last100Stats.totalPredictions}
            â€¢ Genauigkeit: ${decimalFormat.format(stats.last100Stats.accuracy)}%
            â€¢ Durchschnittlicher Fehler: ${decimalFormat.format(stats.last100Stats.averageError)}
        """.trimIndent()

        binding.stats1000.text = """
            Letzte 1000 Vorhersagen:
            â€¢ Korrekte Vorhersagen: ${stats.last1000Stats.correctPredictions}/${stats.last1000Stats.totalPredictions}
            â€¢ Genauigkeit: ${decimalFormat.format(stats.last1000Stats.accuracy)}%
            â€¢ Durchschnittlicher Fehler: ${decimalFormat.format(stats.last1000Stats.averageError)}
        """.trimIndent()

        // Erweiterte Statistiken
        binding.extendedStats.text = """
            Erweiterte Statistiken:
            â€¢ HÃ¤ufigste Zahl: ${stats.extendedStats.mostCommonNumber}
            â€¢ Seltenste Zahl: ${stats.extendedStats.leastCommonNumber}
            â€¢ LÃ¤ngste korrekte Serie: ${stats.extendedStats.maxConsecutiveCorrect}
            â€¢ Gesamtanzahl Vorhersagen: ${stats.extendedStats.totalPredictions}
        """.trimIndent()
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        return when (item.itemId) {
            android.R.id.home -> {
                onBackPressed()
                true
            }
            else -> super.onOptionsItemSelected(item)
        }
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\ui\StatisticsViewModel.kt
==========================================

package com.roulette.tracker.ui

import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.roulette.tracker.data.repository.SimulationRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.launch
import javax.inject.Inject
import java.util.concurrent.TimeUnit
import kotlinx.coroutines.Dispatchers
import timber.log.Timber

data class StatisticsData(
    val accuracyData: List<Float> = emptyList(),
    val predictionData: List<Pair<Int, Int>> = emptyList(),
    val last100Stats: StatsSummary = StatsSummary(),
    val last1000Stats: StatsSummary = StatsSummary(),
    val extendedStats: ExtendedStats = ExtendedStats()
)

data class StatsSummary(
    val totalPredictions: Int = 0,
    val correctPredictions: Int = 0,
    val accuracy: Float = 0f,
    val averageError: Float = 0f
)

data class ExtendedStats(
    val mostCommonNumber: Int = 0,
    val leastCommonNumber: Int = 0,
    val maxConsecutiveCorrect: Int = 0,
    val totalPredictions: Int = 0
)

@HiltViewModel
class StatisticsViewModel @Inject constructor(
    private val repository: SimulationRepository
) : ViewModel() {

    private val _statisticsData = MutableLiveData<StatisticsData>()
    val statisticsData: LiveData<StatisticsData> = _statisticsData

    private val _isLoading = MutableLiveData<Boolean>()
    val isLoading: LiveData<Boolean> = _isLoading

    private val _error = MutableLiveData<String?>()
    val error: LiveData<String?> = _error

    private val _timeRange = MutableLiveData(TimeRange.ALL)
    val timeRange: LiveData<TimeRange> = _timeRange

    enum class TimeRange {
        LAST_24H, LAST_WEEK, LAST_MONTH, ALL
    }

    init {
        loadStatistics()
    }

    fun setTimeRange(range: TimeRange) {
        _timeRange.value = range
        loadStatistics()
    }

    private fun loadStatistics() {
        viewModelScope.launch {
            try {
                _isLoading.value = true
                _error.value = null
                
                val allSimulations = repository.getAllSimulations()
                if (allSimulations.isEmpty()) {
                    _error.value = "Keine Daten verfÃ¼gbar"
                    return@launch
                }

                val filteredSimulations = filterSimulationsByTimeRange(allSimulations)
                
                val accuracyList = filteredSimulations.map { it.accuracy.toFloat() }
                val predictionsList = filteredSimulations.map { Pair(it.predictedNumber, it.actualNumber) }

                val stats = calculateExtendedStats(filteredSimulations)
                val last100Stats = calculateStats(filteredSimulations.takeLast(100))
                val last1000Stats = calculateStats(filteredSimulations.takeLast(1000))

                _statisticsData.value = StatisticsData(
                    accuracyData = accuracyList,
                    predictionData = predictionsList,
                    last100Stats = last100Stats,
                    last1000Stats = last1000Stats,
                    extendedStats = stats
                )
            } catch (e: Exception) {
                _error.value = "Fehler beim Laden der Statistiken: ${e.localizedMessage}"
                Timber.e(e, "Fehler beim Laden der Statistiken")
            } finally {
                _isLoading.value = false
            }
        }
    }

    private fun filterSimulationsByTimeRange(simulations: List<SimulationEntity>): List<SimulationEntity> {
        val currentTime = System.currentTimeMillis()
        return when (_timeRange.value) {
            TimeRange.LAST_24H -> simulations.filter { 
                (currentTime - it.timestamp) < TimeUnit.DAYS.toMillis(1) 
            }
            TimeRange.LAST_WEEK -> simulations.filter { 
                (currentTime - it.timestamp) < TimeUnit.DAYS.toMillis(7) 
            }
            TimeRange.LAST_MONTH -> simulations.filter { 
                (currentTime - it.timestamp) < TimeUnit.DAYS.toMillis(30) 
            }
            TimeRange.ALL -> simulations
            else -> simulations
        }
    }

    private fun calculateExtendedStats(simulations: List<SimulationEntity>): ExtendedStats {
        if (simulations.isEmpty()) return ExtendedStats()

        val numberFrequency = simulations.groupBy { it.actualNumber }
            .mapValues { it.value.size }
        
        val mostCommonNumber = numberFrequency.maxByOrNull { it.value }?.key ?: 0
        val leastCommonNumber = numberFrequency.minByOrNull { it.value }?.key ?: 0

        val consecutiveCorrect = simulations
            .asSequence()
            .windowed(size = 2, step = 1)
            .map { it[0].predictedNumber == it[0].actualNumber && it[1].predictedNumber == it[1].actualNumber }
            .fold(Pair(0, 0)) { (max, current), isCorrect ->
                when {
                    isCorrect -> Pair(maxOf(max, current + 1), current + 1)
                    else -> Pair(max, 0)
                }
            }.first

        return ExtendedStats(
            mostCommonNumber = mostCommonNumber,
            leastCommonNumber = leastCommonNumber,
            maxConsecutiveCorrect = consecutiveCorrect,
            totalPredictions = simulations.size
        )
    }

    private fun calculateStats(simulations: List<SimulationEntity>): StatsSummary {
        if (simulations.isEmpty()) return StatsSummary()

        val totalPredictions = simulations.size
        val correctPredictions = simulations.count { it.predictedNumber == it.actualNumber }
        val accuracy = (correctPredictions.toFloat() / totalPredictions) * 100
        val averageError = simulations
            .map { Math.abs(it.predictedNumber - it.actualNumber) }
            .average()
            .toFloat()

        return StatsSummary(
            totalPredictions = totalPredictions,
            correctPredictions = correctPredictions,
            accuracy = accuracy,
            averageError = averageError
        )
    }

    fun refreshStatistics() {
        loadStatistics()
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\ui\TestActivity.kt
==========================================

package com.roulette.tracker

import android.os.Bundle
import android.util.Log
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import org.opencv.android.OpenCVLoader

class TestActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // OpenCV initialisieren
        if (!OpenCVLoader.initDebug()) {
            Log.e("OpenCV", "OpenCV initialization failed")
            Toast.makeText(this, "OpenCV konnte nicht initialisiert werden", Toast.LENGTH_LONG).show()
        } else {
            Log.d("OpenCV", "OpenCV initialization succeeded")
            Toast.makeText(this, "OpenCV erfolgreich initialisiert", Toast.LENGTH_SHORT).show()
        }
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\ui\TrackingActivity.kt
==========================================

package com.roulette.tracker

import android.content.Context
import android.net.Uri
import android.os.Bundle
import android.util.Log
import android.view.View
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.viewModels
import com.roulette.tracker.camera.CameraManager
import com.roulette.tracker.camera.CameraPreviewManager
import com.roulette.tracker.camera.FrameAnalyzer
import com.roulette.tracker.data.BallTracker
import com.roulette.tracker.data.PredictionEngine
import com.roulette.tracker.data.WheelTracker
import com.roulette.tracker.data.BallData
import com.roulette.tracker.data.WheelData
import com.roulette.tracker.data.PredictionResult
import com.roulette.tracker.databinding.ActivityTrackingBinding
import com.roulette.tracker.tracking.TrackingStateManager
import kotlinx.coroutines.launch
import org.opencv.core.*
import org.opencv.imgproc.Imgproc
import dagger.hilt.android.AndroidEntryPoint
import javax.inject.Inject

@AndroidEntryPoint
class TrackingActivity : AppCompatActivity() {
    @Inject lateinit var ballTracker: BallTracker
    @Inject lateinit var wheelTracker: WheelTracker
    @Inject lateinit var predictionEngine: PredictionEngine
    private lateinit var binding: ActivityTrackingBinding
    private lateinit var systemCameraManager: android.hardware.camera2.CameraManager
    private lateinit var cameraManager: CameraManager
    private lateinit var cameraPreviewManager: CameraPreviewManager
    private lateinit var trackingStateManager: TrackingStateManager
    private val viewModel: TrackingViewModel by viewModels()
    
    private var frameAnalyzer: FrameAnalyzer? = null
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityTrackingBinding.inflate(layoutInflater)
        setContentView(binding.root)
        
        initializeManagers()
        setupObservers()
        setupUI()
    }

    private fun initializeManagers() {
        systemCameraManager = getSystemService(Context.CAMERA_SERVICE) as android.hardware.camera2.CameraManager
        cameraManager = CameraManager(this, this, systemCameraManager)
        cameraPreviewManager = CameraPreviewManager(this)
        trackingStateManager = TrackingStateManager()
    }

    private fun setupObservers() {
        lifecycleScope.launch {
            viewModel.trackingState.collect { state ->
                updateUI(state)
            }
        }
    }

    private fun setupUI() {
        binding.btnStartStop.setOnClickListener {
            if (viewModel.isTracking) {
                stopTracking()
            } else {
                startTracking()
            }
        }
    }

    private fun startTracking() {
        if (!checkPermissions()) return
        
        lifecycleScope.launch {
            when (val result = initializeCamera()) {
                is CameraResult.Success -> viewModel.startTracking()
                is CameraResult.Error -> showError(result.exception.message)
            }
        }
    }

    private fun stopTracking() {
        viewModel.stopTracking()
        cameraManager.stopCamera()
    }

    private fun initializeCamera(): CameraResult {
        try {
            frameAnalyzer = FrameAnalyzer { frame ->
                processFrame(frame)
            }
            lifecycleScope.launch {
                cameraManager.startCamera(
                    binding.previewView,
                    frameAnalyzer!!
                )
            }
            return CameraResult.Success
        } catch (e: Exception) {
            Log.e(TAG, "Fehler beim Kamera-Setup: ${e.message}")
            return CameraResult.Error(e)
        }
    }

    private fun processFrame(frame: Mat) {
        try {
            trackingStateManager.startTracking()
            
            val ballData = ballTracker.trackBall(frame)
            if (ballData.currentPosition == Point(0.0, 0.0)) {
                trackingStateManager.ballLost()
                return
            }
            
            val wheelData = wheelTracker.trackWheel(frame)
            if (wheelData.centerPoint == null) {
                trackingStateManager.wheelLost()
                return
            }
            
            showDebugFrame(frame, ballData, wheelData)
            binding.predictionOverlay.updateDebugInfo(ballData.velocity, wheelData.rotationSpeed)
            
            if (ballData.predictedLandingTime > 0) {
                trackingStateManager.startPrediction(ballData.predictedLandingTime - System.currentTimeMillis())
            }
            
            val prediction = predictionEngine.predict(ballData, wheelData)
            trackingStateManager.predictionComplete(prediction)
            updateUI(prediction)
            
        } catch (e: Exception) {
            Log.e(TAG, "Error processing frame: ${e.message}")
            trackingStateManager.reportError(e.message ?: "Unbekannter Fehler")
        }
    }

    private fun showDebugFrame(frame: Mat, ballData: BallData, wheelData: WheelData) {
        try {
            Imgproc.circle(
                frame, 
                ballData.currentPosition,
                5,
                Scalar(0.0, 255.0, 0.0),
                2
            )
            
            wheelData.visibleNumbers.forEachIndexed { index, number ->
                Imgproc.putText(
                    frame,
                    number.toString(),
                    Point(10.0, ((index + 1) * 30).toDouble()),
                    Imgproc.FONT_HERSHEY_SIMPLEX,
                    1.0,
                    Scalar(255.0, 255.0, 255.0),
                    2
                )
            }
            
            cameraPreviewManager.showPreview(frame, binding.debugPreview)
        } catch (e: Exception) {
            Log.e(TAG, "Error showing debug frame: ${e.message}")
        }
    }

    private fun updateUI(prediction: PredictionResult) {
        binding.predictionOverlay.updatePrediction(prediction)
    }

    private fun showError(message: String) {
        Toast.makeText(this, message, Toast.LENGTH_LONG).show()
    }

    private fun checkPermissions(): Boolean {
        // Implement the logic to check permissions
        return true // Placeholder return, actual implementation needed
    }

    override fun onDestroy() {
        super.onDestroy()
        stopTracking()
        binding.videoView.stopPlayback()
        try {
            cameraPreviewManager.release()
        } catch (e: Exception) {
            Log.e(TAG, "Error in onDestroy: ${e.message}")
        }
    }

    companion object {
        private const val TAG = "TrackingActivity"
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\ui\settings\SettingsFragment.kt
==========================================

package com.roulette.tracker.ui.settings

import androidx.fragment.app.Fragment
import dagger.hilt.android.AndroidEntryPoint

@AndroidEntryPoint
class SettingsFragment : Fragment() {
    // ... dein existierender Code ...
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\ui\stats\StatsFragment.kt
==========================================

package com.roulette.tracker.ui.stats

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import androidx.fragment.app.viewModels
import androidx.core.content.ContextCompat
import com.github.mikephil.charting.data.Entry
import com.github.mikephil.charting.data.LineData
import com.github.mikephil.charting.data.LineDataSet
import dagger.hilt.android.AndroidEntryPoint
import com.roulette.tracker.databinding.FragmentStatsBinding
import com.roulette.tracker.viewBinding

@AndroidEntryPoint
class StatsFragment : Fragment() {
    private val viewModel: StatsViewModel by viewModels()
    private val binding by viewBinding(FragmentStatsBinding::bind)

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        return FragmentStatsBinding.inflate(inflater, container, false).root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        
        viewModel.allResults.observe(viewLifecycleOwner) { results ->
            with(binding) {
                // Statistiken aktualisieren
                totalPredictionsText.text = getString(R.string.total_predictions, results.size)
                val successful = results.count { it.wasSuccessful }
                successfulPredictionsText.text = getString(R.string.successful_predictions, successful)
                
                val successRate = if (results.isNotEmpty()) {
                    (successful.toFloat() / results.size) * 100
                } else 0f
                successRateText.text = getString(R.string.success_rate, successRate)
                
                val avgConfidence = results.map { it.confidence }.average().toInt()
                averageConfidenceText.text = getString(R.string.average_confidence, avgConfidence)
                
                val avgTimeToLanding = results.map { it.timeToLanding }.average()
                averageTimeToLandingText.text = getString(
                    R.string.average_time_to_landing, 
                    avgTimeToLanding
                )

                // Charts aktualisieren
                updateConfidenceChart(results)
                updateTimeToLandingChart(results)
            }
        }
        
        viewModel.accuracyRate.observe(viewLifecycleOwner) { rate ->
            binding.trendText.text = getString(R.string.trend, rate)
        }
    }

    private fun updateConfidenceChart(results: List<PredictionResult>) {
        binding.confidenceChart.apply {
            description.isEnabled = false
            setTouchEnabled(true)
            isDragEnabled = true
            setScaleEnabled(true)
            setPinchZoom(true)
            
            val entries = results.mapIndexed { index, result ->
                Entry(index.toFloat(), result.confidence)
            }
            
            val dataSet = LineDataSet(entries, getString(R.string.chart_confidence)).apply {
                setDrawValues(false)
                setDrawCircles(false)
                lineWidth = 2f
                color = ContextCompat.getColor(requireContext(), R.color.chart_line)
                mode = LineDataSet.Mode.CUBIC_BEZIER
            }
            
            data = LineData(dataSet)
            invalidate()
        }
    }

    private fun updateTimeToLandingChart(results: List<PredictionResult>) {
        binding.timeToLandingChart.apply {
            description.isEnabled = false
            setTouchEnabled(true)
            isDragEnabled = true
            setScaleEnabled(true)
            setPinchZoom(true)
            
            val entries = results.mapIndexed { index, result ->
                Entry(index.toFloat(), result.timeToLanding)
            }
            
            val dataSet = LineDataSet(entries, getString(R.string.chart_time_to_landing)).apply {
                setDrawValues(false)
                setDrawCircles(false)
                lineWidth = 2f
                color = ContextCompat.getColor(requireContext(), R.color.chart_line)
                mode = LineDataSet.Mode.CUBIC_BEZIER
            }
            
            data = LineData(dataSet)
            invalidate()
        }
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\ui\stats\StatsViewModel.kt
==========================================

package com.roulette.tracker.ui.stats

import androidx.lifecycle.ViewModel
import com.roulette.tracker.data.repository.SimulationRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject

@HiltViewModel
class StatsViewModel @Inject constructor(
    private val repository: SimulationRepository
) : ViewModel() {
    val allResults = repository.allResults
    val accuracyRate = repository.accuracyRate
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\ui\theme\Color.kt
==========================================

package com.roulette.tracker.ui.theme

import androidx.compose.ui.graphics.Color

val Purple80 = Color(0xFFD0BCFF)
val PurpleGrey80 = Color(0xFFCCC2DC)
val Pink80 = Color(0xFFEFB8C8)

val Purple40 = Color(0xFF6650a4)
val PurpleGrey40 = Color(0xFF625b71)
val Pink40 = Color(0xFF7D5260)

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\ui\theme\Theme.kt
==========================================

package com.roulette.tracker.ui.theme

import android.app.Activity
import android.os.Build
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.dynamicDarkColorScheme
import androidx.compose.material3.dynamicLightColorScheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.ui.platform.LocalContext

private val DarkColorScheme = darkColorScheme(
    primary = Purple80,
    secondary = PurpleGrey80,
    tertiary = Pink80
)

private val LightColorScheme = lightColorScheme(
    primary = Purple40,
    secondary = PurpleGrey40,
    tertiary = Pink40

    /* Other default colors to override
    background = Color(0xFFFFFBFE),
    surface = Color(0xFFFFFBFE),
    onPrimary = Color.White,
    onSecondary = Color.White,
    onTertiary = Color.White,
    onBackground = Color(0xFF1C1B1F),
    onSurface = Color(0xFF1C1B1F),
    */
)

@Composable
fun Roulette2Theme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    // Dynamic color is available on Android 12+
    dynamicColor: Boolean = true,
    content: @Composable () -> Unit
) {
    val colorScheme = when {
        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
            val context = LocalContext.current
            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
        }

        darkTheme -> DarkColorScheme
        else -> LightColorScheme
    }

    MaterialTheme(
        colorScheme = colorScheme,
        typography = Typography,
        content = content
    )
}

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\ui\theme\Type.kt
==========================================

package com.roulette.tracker.ui.theme

import androidx.compose.material3.Typography
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp

// Set of Material typography styles to start with
val Typography = Typography(
    bodyLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 16.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.5.sp
    )
    /* Other default text styles to override
    titleLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 22.sp,
        lineHeight = 28.sp,
        letterSpacing = 0.sp
    ),
    labelSmall = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Medium,
        fontSize = 11.sp,
        lineHeight = 16.sp,
        letterSpacing = 0.5.sp
    )
    */
)

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\ui\tracking\BaseFrameProvider.kt
==========================================

package com.roulette.tracker.ui.tracking

import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import org.opencv.core.Mat
import java.util.concurrent.atomic.AtomicLong
import timber.log.Timber

abstract class BaseFrameProvider : FrameProvider {
    protected var isActive = true
    private val frameCount = AtomicLong(0)
    private val droppedFrames = AtomicLong(0)
    private val _metrics = MutableStateFlow(FrameMetrics())
    val metrics: StateFlow<FrameMetrics> = _metrics
    
    protected fun updateMetrics(processed: Boolean = true) {
        if (processed) {
            frameCount.incrementAndGet()
        } else {
            droppedFrames.incrementAndGet()
        }
        _metrics.value = FrameMetrics(
            totalFrames = frameCount.get(),
            droppedFrames = droppedFrames.get(),
            fps = calculateFps()
        )
    }
    
    private var lastFpsCalculation = 0L
    private var framesSinceLastCalculation = 0
    private var currentFps = 0f
    
    private fun calculateFps(): Float {
        val now = System.currentTimeMillis()
        if (lastFpsCalculation == 0L) {
            lastFpsCalculation = now
            return 0f
        }
        
        framesSinceLastCalculation++
        val timeDiff = now - lastFpsCalculation
        
        if (timeDiff >= 1000) {  // Aktualisiere FPS jede Sekunde
            currentFps = (framesSinceLastCalculation * 1000f) / timeDiff
            framesSinceLastCalculation = 0
            lastFpsCalculation = now
        }
        
        return currentFps
    }
    
    protected fun handleError(e: Exception, message: String) {
        Timber.e(e, message)
        updateMetrics(false)
    }
    
    fun stop() {
        isActive = false
    }
    
    fun start() {
        isActive = true
        resetMetrics()
    }
    
    private fun resetMetrics() {
        frameCount.set(0)
        droppedFrames.set(0)
        lastFpsCalculation = 0
        framesSinceLastCalculation = 0
        currentFps = 0f
        _metrics.value = FrameMetrics()
    }
    
    protected fun Mat.safeRelease() {
        try {
            if (!this.empty()) {
                this.release()
            }
        } catch (e: Exception) {
            handleError(e, "Error releasing Mat")
        }
    }
}

data class FrameMetrics(
    val totalFrames: Long = 0,
    val droppedFrames: Long = 0,
    val fps: Float = 0f
) 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\ui\tracking\CameraFrameProvider.kt
==========================================

package com.roulette.tracker.ui.tracking

import android.view.Surface
import androidx.camera.core.ImageAnalysis
import androidx.lifecycle.DefaultLifecycleObserver
import androidx.lifecycle.LifecycleOwner
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.opencv.core.Mat
import javax.inject.Inject
import com.roulette.tracker.camera.CameraManager
import com.roulette.tracker.utils.OpenCVManager
import kotlinx.coroutines.channels.Channel.Factory.BUFFERED
import android.util.Log
import androidx.camera.view.PreviewView
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.flow.flowOn
import androidx.camera.core.ResolutionSelector
import androidx.camera.core.AspectRatio
import androidx.camera.core.ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST
import timber.log.Timber
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import com.roulette.tracker.camera.FrameAnalyzerFactory
import com.roulette.tracker.camera.FrameAnalyzerConfig

class CameraFrameProvider @Inject constructor(
    private val cameraManager: CameraManager,
    private val openCVManager: OpenCVManager,
    private val config: FrameProviderConfig,
    private val frameAnalyzerFactory: FrameAnalyzerFactory
) : BaseFrameProvider(), DefaultLifecycleObserver {
    
    private val frameChannel = Channel<Mat>(BUFFERED)
    private var previewView: PreviewView? = null
    private val frameAnalyzer = frameAnalyzerFactory.create(
        onFrameAnalyzed = { mat ->
            if (isActive) {
                val frameCopy = mat.clone()
                val sent = frameChannel.trySend(frameCopy).isSuccess
                if (!sent) {
                    frameCopy.safeRelease()
                } else {
                    _cameraMetrics.value = _cameraMetrics.value.copy(
                        isRunning = true,
                        lastError = null
                    )
                }
            }
        },
        config = FrameAnalyzerConfig(
            targetFps = config.frameRate,
            colorConversion = FrameAnalyzerConfig.ColorConversion.YUV2BGR
        )
    )

    private val _cameraMetrics = MutableStateFlow(CameraMetrics())
    val cameraMetrics: StateFlow<CameraMetrics> = _cameraMetrics
    
    fun setPreviewView(view: PreviewView) {
        previewView = view
    }
    
    override fun onResume(owner: LifecycleOwner) {
        super.onResume(owner)
        isActive = true
    }

    override fun onPause(owner: LifecycleOwner) {
        super.onPause(owner)
        stopCamera()
    }
    
    override fun onError(error: Throwable) {
        handleError(error as? Exception ?: Exception(error), "Camera error")
    }
    
    override suspend operator fun invoke(): Mat? = withContext(Dispatchers.Default) {
        if (!isActive) return@withContext null
        
        try {
            frameChannel.receive()
        } catch (e: Exception) {
            Log.e(TAG, "Error receiving frame", e)
            null
        }
    }

    fun getFrameFlow(): Flow<Mat> = flow {
        while (isActive) {
            getNextFrame()?.let { frame ->
                emit(frame)
            }
        }
    }.flowOn(Dispatchers.Default)
    
    fun stopCamera() {
        isActive = false
        cameraManager.stopCamera()
        frameChannel.close()
    }
    
    companion object {
        private const val TAG = "CameraFrameProvider"
    }
}

data class CameraMetrics(
    val isRunning: Boolean = false,
    val lastError: String? = null,
    val errorCount: Int = 0
) 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\ui\tracking\CameraLifecycleManager.kt
==========================================

package com.roulette.tracker.ui.tracking

import androidx.lifecycle.DefaultLifecycleObserver
import androidx.lifecycle.LifecycleOwner
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.cancel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import javax.inject.Inject
import timber.log.Timber

class CameraLifecycleManager @Inject constructor() : DefaultLifecycleObserver {
    private val scope = CoroutineScope(SupervisorJob() + Dispatchers.Main)
    private val _state = MutableStateFlow<CameraState>(CameraState.Initialized)
    val state: StateFlow<CameraState> = _state
    
    private var frameProvider: CameraFrameProvider? = null
    
    fun registerFrameProvider(provider: CameraFrameProvider) {
        frameProvider = provider
    }
    
    override fun onResume(owner: LifecycleOwner) {
        try {
            frameProvider?.let { provider ->
                _state.value = CameraState.Starting
                provider.start()
                _state.value = CameraState.Running
            }
        } catch (e: Exception) {
            Timber.e(e, "Error resuming camera")
            _state.value = CameraState.Error(e)
        }
    }
    
    override fun onPause(owner: LifecycleOwner) {
        try {
            frameProvider?.let { provider ->
                _state.value = CameraState.Stopping
                provider.stop()
                _state.value = CameraState.Stopped
            }
        } catch (e: Exception) {
            Timber.e(e, "Error pausing camera")
            _state.value = CameraState.Error(e)
        }
    }
    
    override fun onDestroy(owner: LifecycleOwner) {
        scope.cancel()
        frameProvider = null
    }
}

sealed class CameraState {
    object Initialized : CameraState()
    object Starting : CameraState()
    object Running : CameraState()
    object Stopping : CameraState()
    object Stopped : CameraState()
    data class Error(val exception: Exception) : CameraState()
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\ui\tracking\FrameProvider.kt
==========================================

package com.roulette.tracker.ui.tracking

import org.opencv.core.Mat
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow

/**
 * Funktionale Schnittstelle fÃ¼r die Bereitstellung von Frames
 */
fun interface FrameProvider {
    /**
     * Liefert den nÃ¤chsten Frame oder null, wenn kein Frame verfÃ¼gbar ist
     * @return Mat? Der nÃ¤chste Frame oder null
     */
    suspend fun getNextFrame(): Mat?
}

/**
 * Basis-Implementierung des FrameProviders
 */
abstract class BaseFrameProvider : FrameProvider {
    protected var isActive = true
    
    /**
     * Beendet die Frame-Bereitstellung
     */
    fun stop() {
        isActive = false
    }
    
    /**
     * Startet die Frame-Bereitstellung neu
     */
    fun start() {
        isActive = true
    }
}

/**
 * Erweiterte Version des FrameProcessors mit besserer Fehlerbehandlung
 */
class FrameProcessor(private val frameProvider: FrameProvider) {
    private var isProcessing = true
    private var errorHandler: (Throwable) -> Unit = { }
    
    fun processFrames(): Flow<Mat?> = flow {
        while (isProcessing) {
            try {
                frameProvider.getNextFrame()?.let { frame ->
                    if (!frame.empty()) {
                        emit(frame)
                    } else {
                        frame.release()
                    }
                }
            } catch (e: Exception) {
                errorHandler(e)
            }
        }
    }
    
    fun setErrorHandler(handler: (Throwable) -> Unit) {
        errorHandler = handler
    }
    
    fun release() {
        isProcessing = false
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\ui\tracking\FrameProviderConfig.kt
==========================================

package com.roulette.tracker.ui.tracking

data class FrameProviderConfig(
    val frameRate: Int = 30,
    val resolution: Resolution = Resolution.HD,
    val useHardwareAcceleration: Boolean = true
) {
    enum class Resolution(val width: Int, val height: Int) {
        HD(1280, 720),
        FULL_HD(1920, 1080),
        UHD(3840, 2160)
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\ui\tracking\TestFrameProvider.kt
==========================================

package com.roulette.tracker.ui.tracking

import org.opencv.core.Mat
import org.opencv.imgcodecs.Imgcodecs
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import kotlinx.coroutines.delay
import android.content.Context
import android.content.res.AssetManager
import javax.inject.Inject
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.flow.flowOn
import org.opencv.core.CvType
import java.io.File

class TestFrameProvider @Inject constructor(
    private val context: Context
) : BaseFrameProvider() {
    
    private var frameCount = 0
    private val testFrames = mutableListOf<Mat>()
    
    init {
        loadTestFrames()
    }
    
    private fun loadTestFrames() {
        try {
            context.assets.list("test_frames")?.forEach { fileName ->
                if (fileName.endsWith(".jpg") || fileName.endsWith(".png")) {
                    val inputStream = context.assets.open("test_frames/$fileName")
                    val file = File(context.cacheDir, fileName)
                    file.outputStream().use { output ->
                        inputStream.copyTo(output)
                    }
                    val mat = Imgcodecs.imread(file.absolutePath)
                    if (!mat.empty()) {
                        testFrames.add(mat)
                    }
                }
            }
        } catch (e: Exception) {
            // Fallback: Erstelle einen leeren Frame
            testFrames.add(Mat(720, 1280, CvType.CV_8UC3))
        }
    }
    
    override suspend fun getNextFrame(): Mat? = withContext(Dispatchers.IO) {
        if (!isActive) return@withContext null
        
        try {
            delay(33) // ~30 FPS
            val frame = testFrames[frameCount % testFrames.size].clone()
            frameCount++
            frame
        } catch (e: Exception) {
            null
        }
    }

    fun getFrameFlow(): Flow<Mat> = flow {
        while (isActive) {
            getNextFrame()?.let { frame ->
                emit(frame)
            }
        }
    }.flowOn(Dispatchers.IO)
    
    override fun onCleared() {
        super.onCleared()
        testFrames.forEach { it.release() }
        testFrames.clear()
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\ui\tracking\TrackingFragment.kt
==========================================

package com.roulette.tracker.ui.tracking

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import dagger.hilt.android.AndroidEntryPoint

@AndroidEntryPoint
class TrackingFragment : Fragment() {
    private var _binding: FragmentTrackingBinding? = null
    private val binding get() = _binding!!
    
    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        _binding = FragmentTrackingBinding.inflate(inflater, container, false)
        return binding.root
    }
    
    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\ui\tracking\TrackingViewModel.kt
==========================================

package com.roulette.tracker.ui.tracking

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.roulette.tracker.data.BallTracker
import com.roulette.tracker.data.WheelTracker
import com.roulette.tracker.PredictionEngine
import com.roulette.tracker.data.repository.SimulationRepository
import com.roulette.tracker.data.TrackingState
import com.roulette.tracker.data.BallData
import com.roulette.tracker.data.WheelData
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.isActive
import javax.inject.Inject
import org.opencv.core.Mat
import com.roulette.tracker.data.entities.SimulationResult
import kotlinx.coroutines.withContext
import kotlinx.coroutines.Dispatchers
import android.util.Log
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.channels.consumeEach
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock
import java.util.concurrent.atomic.AtomicBoolean
import kotlinx.coroutines.channels.BufferOverflow
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.atomic.AtomicLong
import kotlinx.coroutines.channels.Channel.Factory.UNLIMITED
import java.util.concurrent.atomic.AtomicReference
import kotlin.time.TimeSource

@HiltViewModel
class TrackingViewModel @Inject constructor(
    private val ballTracker: BallTracker,
    private val wheelTracker: WheelTracker,
    private val predictionEngine: PredictionEngine,
    private val simulationRepository: SimulationRepository
) : ViewModel() {
    private val _trackingState = MutableStateFlow<TrackingState>(TrackingState.INITIALIZING)
    val trackingState = _trackingState.asStateFlow()
        .distinctUntilChanged()
        .onEach { state -> logStateTransition(state) }
        .debounce(STATE_UPDATE_DEBOUNCE)
        .sample(STATE_SAMPLING_INTERVAL)
    
    private val errorChannel = Channel<String>(Channel.BUFFERED)
    private val frameMetrics = ConcurrentHashMap<String, Long>()
    private val _processingStats = MutableStateFlow(ProcessingStats())
    val processingStats = _processingStats.asStateFlow()
        .distinctUntilChanged()
        .shareIn(viewModelScope, SharingStarted.Lazily, 1)
    
    private val frameCount = AtomicLong(0)
    private val lastFrameTime = AtomicLong(0)
    private val startTime = AtomicReference(TimeSource.Monotonic.markNow())
    private val lastMetricsUpdate = AtomicLong(0)
    
    private var trackingJob: Job? = null
    private var frameProcessor: FrameProcessor? = null
    private var lastPredictionTime = 0L
    private val predictionMutex = Mutex()
    private val isTracking = AtomicBoolean(false)
    
    init {
        handleErrors()
    }

    private fun handleErrors() {
        viewModelScope.launch {
            errorChannel.consumeEach { errorMessage ->
                Log.e(TAG, errorMessage)
                _trackingState.value = TrackingState.Error(errorMessage)
            }
        }
    }
    
    fun startTracking(frameProvider: FrameProvider) {
        if (!isTracking.compareAndSet(false, true)) {
            return // Verhindere mehrfaches Starten
        }

        trackingJob?.cancel()
        frameProcessor = FrameProcessor(frameProvider)
        
        trackingJob = viewModelScope.launch {
            try {
                initializeTracking()
                processFrames()
            } catch (e: Exception) {
                handleError("Tracking-Fehler: ${e.message}")
            } finally {
                isTracking.set(false)
            }
        }
    }

    fun stopTracking() {
        if (isTracking.compareAndSet(true, false)) {
            cleanup()
            _trackingState.value = TrackingState.INITIALIZING
        }
    }

    private suspend fun initializeTracking() {
        _trackingState.value = TrackingState.Running
        lastPredictionTime = 0L
    }

    private suspend fun processFrames() {
        frameProcessor?.processFrames()
            ?.buffer(UNLIMITED)
            ?.filterNotNull()
            ?.onEach { updateFrameMetrics() }
            ?.transformWhile { frame ->
                if (!isTracking.get()) {
                    false // Stoppt die Transformation
                } else {
                    emit(frame)
                    true // Fortsetzung
                }
            }
            ?.map { frame -> 
                measureFrameProcessing {
                    processFrame(frame)
                }
            }
            ?.flowOn(Dispatchers.Default)
            ?.retry(FRAME_RETRY_COUNT) { e ->
                val shouldRetry = handleRetry(e)
                if (shouldRetry) delay(calculateBackoffDelay())
                shouldRetry && isTracking.get()
            }
            ?.catch { e -> handleError("Frame-Processing-Fehler: ${e.message}") }
            ?.collect()
    }

    private fun calculateBackoffDelay(): Long {
        val retryCount = (frameMetrics["retryCount"] ?: 0) + 1
        frameMetrics["retryCount"] = retryCount
        return minOf(
            FRAME_RETRY_DELAY * (1L shl (retryCount - 1)), // Exponentielles Backoff
            MAX_RETRY_DELAY
        )
    }

    private fun updateFrameMetrics() {
        frameCount.incrementAndGet()
        val currentTime = System.nanoTime()
        lastFrameTime.set(currentTime)
        
        // Periodische Metrik-Updates
        if (shouldUpdateMetrics(currentTime)) {
            updateDetailedMetrics()
        }
    }

    private fun shouldUpdateMetrics(currentTime: Long): Boolean {
        val lastUpdate = lastMetricsUpdate.get()
        return (currentTime - lastUpdate) >= METRICS_UPDATE_INTERVAL * 1_000_000 && 
               lastMetricsUpdate.compareAndSet(lastUpdate, currentTime)
    }

    private fun updateDetailedMetrics() {
        val currentStats = ProcessingStats(
            frameRate = calculateCurrentFrameRate(),
            processingTime = measureProcessingTime(),
            successRate = calculateSuccessRate(),
            errorRate = calculateErrorRate(),
            averageProcessingTime = calculateAverageProcessingTime(),
            totalFrames = frameCount.get(),
            droppedFrames = calculateDroppedFrames(),
            memoryUsage = calculateMemoryUsage(),
            cpuUsage = calculateCpuUsage()
        )
        
        _processingStats.value = currentStats
        
        // Log wichtige Metriken
        if (currentStats.errorRate > ERROR_RATE_THRESHOLD || 
            currentStats.droppedFrames > DROPPED_FRAMES_THRESHOLD) {
            Log.w(TAG, "Performance-Warnung: $currentStats")
        }
    }

    private fun calculateMemoryUsage(): Float {
        val runtime = Runtime.getRuntime()
        val used = runtime.totalMemory() - runtime.freeMemory()
        return used.toFloat() / runtime.maxMemory()
    }

    private fun calculateCpuUsage(): Float {
        // Vereinfachte CPU-Auslastung basierend auf Verarbeitungszeit
        return (frameMetrics["totalProcessingTime"] ?: 0).toFloat() / 
               (System.nanoTime() - startTime.get().elapsedNow().inWholeNanoseconds)
    }

    private fun handleRetry(error: Throwable): Boolean {
        handleError("Frame-Verarbeitung wird neu versucht: ${error.message}")
        return when (error) {
            is OutOfMemoryError -> false
            is IllegalStateException -> false
            else -> true
        }
    }

    private suspend fun <T> measureFrameProcessing(block: suspend () -> T): T {
        val startTime = System.nanoTime()
        return try {
            block()
        } catch (e: Exception) {
            frameMetrics["processingErrors"] = (frameMetrics["processingErrors"] ?: 0) + 1
            throw e
        } finally {
            val duration = (System.nanoTime() - startTime) / 1_000_000
            updateProcessingMetrics(duration)
        }
    }

    private fun updateProcessingMetrics(duration: Long) {
        frameMetrics["lastFrameTime"] = duration
        frameMetrics["totalProcessingTime"] = 
            (frameMetrics["totalProcessingTime"] ?: 0) + duration
        frameMetrics["frameCount"] = frameCount.get()
        updateProcessingStats()
    }

    private fun calculateCurrentFrameRate(): Float {
        val currentTime = System.nanoTime()
        val lastTime = lastFrameTime.get()
        if (lastTime == 0L) return 0f
        
        val timeDiff = (currentTime - lastTime) / 1_000_000 // ms
        return if (timeDiff > 0) 1000f / timeDiff else 0f
    }

    private fun calculateAverageProcessingTime(): Float {
        val total = frameMetrics["totalProcessingTime"] ?: 0
        val count = frameMetrics["frameCount"] ?: 1
        return total.toFloat() / count
    }

    private fun updateProcessingStats() {
        _processingStats.value = ProcessingStats(
            frameRate = calculateCurrentFrameRate(),
            processingTime = measureProcessingTime(),
            successRate = calculateSuccessRate(),
            errorRate = calculateErrorRate(),
            averageProcessingTime = calculateAverageProcessingTime(),
            totalFrames = frameCount.get(),
            droppedFrames = calculateDroppedFrames()
        )
    }

    private fun calculateDroppedFrames(): Long {
        val expectedFrames = ((System.nanoTime() - startTime.get().elapsedNow().inWholeNanoseconds) / 1_000_000 / FRAME_PROCESSING_DELAY)
        return maxOf(0, expectedFrames - frameCount.get())
    }

    private suspend fun processFrame(frame: Mat) = withContext(Dispatchers.Default) {
        try {
            // Ball tracken
            val ballData = ballTracker.trackBall(frame)
                ?: return@withContext handleTrackingError(TrackingState.BallNotFound)
            
            // Rad tracken
            val wheelData = wheelTracker.trackWheel(frame).also { wheelData ->
                if (!wheelData.isValid()) {
                    return@withContext handleTrackingError(TrackingState.WheelNotFound)
                }
            }
            
            // Vorhersage wenn nÃ¶tig
            checkAndMakePrediction(ballData, wheelData)
            
        } catch (e: Exception) {
            Log.e(TAG, "Fehler bei Frame-Verarbeitung", e)
            handleTrackingError(TrackingState.Error("Frame-Verarbeitung fehlgeschlagen: ${e.message}"))
        } finally {
            frame.release() // OpenCV Ressourcen freigeben
        }
    }
    
    private suspend fun checkAndMakePrediction(ballData: BallData, wheelData: WheelData) {
        if (!isReadyForPrediction(ballData, wheelData)) return
        
        predictionMutex.withLock {
            val currentTime = System.currentTimeMillis()
            if (currentTime - lastPredictionTime <= PREDICTION_INTERVAL) return
            
            makePrediction(ballData, wheelData)
            lastPredictionTime = currentTime
        }
    }

    private fun isReadyForPrediction(ballData: BallData, wheelData: WheelData): Boolean {
        return shouldMakePrediction(ballData, wheelData) && 
               isTrackingStable(ballData, wheelData)
    }

    private fun isTrackingStable(ballData: BallData, wheelData: WheelData): Boolean {
        return ballData.confidence >= MIN_CONFIDENCE &&
               ballData.velocity <= MAX_BALL_VELOCITY &&
               wheelData.rotationSpeed <= MAX_WHEEL_SPEED
    }

    private suspend fun makePrediction(ballData: BallData, wheelData: WheelData) = 
        withContext(Dispatchers.IO) {
            try {
                val prediction = predictionEngine.predict(ballData, wheelData)
                savePrediction(prediction, ballData, wheelData)
                updateTrackingState(prediction)
            } catch (e: Exception) {
                handleError("Vorhersage fehlgeschlagen: ${e.message}")
            }
        }

    private suspend fun savePrediction(
        prediction: PredictionResult,
        ballData: BallData,
        wheelData: WheelData
    ) = withContext(Dispatchers.IO) {
        predictionMutex.withLock {
            val stats = _processingStats.value
            val result = SimulationResult(
                predictedNumber = prediction.predictedNumber,
                confidence = prediction.confidence,
                timestamp = System.currentTimeMillis(),
                ballVelocity = ballData.velocity,
                wheelSpeed = wheelData.rotationSpeed,
                ballConfidence = ballData.confidence,
                wheelConfidence = wheelData.confidence,
                frameRate = stats.frameRate,
                processingTime = stats.processingTime,
                successRate = stats.successRate,
                errorRate = stats.errorRate,
                averageProcessingTime = stats.averageProcessingTime,
                droppedFrames = stats.droppedFrames
            )
            simulationRepository.insertResult(result)
        }
    }

    private suspend fun updateTrackingState(prediction: PredictionResult) {
        withContext(Dispatchers.Main) {
            _trackingState.value = TrackingState.Success(prediction)
        }
    }

    private suspend fun handleError(message: String) {
        errorChannel.send(message)
    }

    private fun shouldMakePrediction(ballData: BallData, wheelData: WheelData): Boolean {
        return ballData.velocity >= MIN_BALL_VELOCITY && 
               wheelData.rotationSpeed >= MIN_WHEEL_SPEED &&
               ballData.confidence >= MIN_CONFIDENCE
    }

    private fun handleTrackingError(error: TrackingState) {
        viewModelScope.launch(Dispatchers.Main) {
            _trackingState.value = error
        }
    }
    
    override fun onCleared() {
        super.onCleared()
        cleanup()
    }
    
    private fun cleanup() {
        trackingJob?.cancel()
        frameProcessor?.release()
        wheelTracker.release()
        predictionEngine.cleanup()
        errorChannel.close()
        frameMetrics.clear()
    }
    
    private fun calculateCurrentFrameRate(): Float {
        // Implementierung der Framerate-Berechnung
        return 1000f / FRAME_PROCESSING_DELAY
    }

    private var lastProcessingTime = 0L
    private fun measureProcessingTime(): Long {
        val current = System.nanoTime()
        val processing = if (lastProcessingTime > 0) {
            (current - lastProcessingTime) / 1_000_000 // Konvertiere zu Millisekunden
        } else 0
        lastProcessingTime = current
        return processing
    }

    private fun logStateTransition(state: TrackingState) {
        Log.d(TAG, "State transition: $state")
        updateMetrics(state)
    }

    private fun updateMetrics(state: TrackingState) {
        when (state) {
            is TrackingState.Success -> {
                frameMetrics["successfulPredictions"] = 
                    (frameMetrics["successfulPredictions"] ?: 0) + 1
            }
            is TrackingState.Error -> {
                frameMetrics["errors"] = (frameMetrics["errors"] ?: 0) + 1
            }
            else -> { /* andere ZustÃ¤nde */ }
        }
        updateProcessingStats()
    }

    private fun calculateSuccessRate(): Float {
        val total = frameMetrics.values.sum()
        return if (total > 0) {
            (frameMetrics["successfulPredictions"] ?: 0).toFloat() / total
        } else 0f
    }

    private fun calculateErrorRate(): Float {
        val total = frameMetrics.values.sum()
        return if (total > 0) {
            (frameMetrics["errors"] ?: 0).toFloat() / total
        } else 0f
    }

    companion object {
        private const val TAG = "TrackingViewModel"
        private const val FRAME_PROCESSING_DELAY = 33L // ~30 FPS
        private const val PREDICTION_INTERVAL = 500L
        private const val MIN_BALL_VELOCITY = 1.0
        private const val MAX_BALL_VELOCITY = 100.0
        private const val MIN_WHEEL_SPEED = 0.1
        private const val MAX_WHEEL_SPEED = 50.0
        private const val MIN_CONFIDENCE = 0.7
        private const val FRAME_RETRY_COUNT = 3L
        private const val FRAME_RETRY_DELAY = 100L
        private const val STATE_UPDATE_DEBOUNCE = 100L
        private const val STATE_SAMPLING_INTERVAL = 250L
        private const val METRICS_UPDATE_INTERVAL = 1000L // 1 Sekunde
        private const val MAX_RETRY_DELAY = 5000L // 5 Sekunden
        private const val ERROR_RATE_THRESHOLD = 0.1f // 10%
        private const val DROPPED_FRAMES_THRESHOLD = 30L // pro Sekunde
    }
}

data class ProcessingStats(
    val frameRate: Float = 0f,
    val processingTime: Long = 0L,
    val successRate: Float = 0f,
    val errorRate: Float = 0f,
    val averageProcessingTime: Float = 0f,
    val totalFrames: Long = 0L,
    val droppedFrames: Long = 0L,
    val memoryUsage: Float = 0f,
    val cpuUsage: Float = 0f
)

class FrameProcessor(private val frameProvider: FrameProvider) {
    private var isProcessing = true
    
    fun processFrames() = flow {
        while (isProcessing) {
            frameProvider.getNextFrame()?.let { emit(it) }
        }
    }
    
    fun release() {
        isProcessing = false
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\utils\ErrorHandler.kt
==========================================

package com.roulette.tracker.utils

import android.content.Context
import javax.inject.Inject

sealed class AppError : Exception() {
    data class CameraError(override val message: String) : AppError()
    data class TrackingError(override val message: String) : AppError()
    data class DatabaseError(override val message: String) : AppError()
    data class OpenCVError(override val message: String) : AppError()
}

class ErrorHandler @Inject constructor(
    private val context: Context
) {
    fun handleError(error: AppError) {
        val errorMessage = when (error) {
            is AppError.CameraError -> context.getString(R.string.error_camera_init, error.message)
            is AppError.TrackingError -> context.getString(R.string.status_error, error.message)
            is AppError.DatabaseError -> "Datenbankfehler: ${error.message}"
            is AppError.OpenCVError -> context.getString(R.string.error_opencv_init, error.message)
        }
        
        Log.e(TAG, errorMessage, error)
        showErrorToast(errorMessage)
    }

    private fun showErrorToast(message: String) {
        Toast.makeText(context, message, Toast.LENGTH_LONG).show()
    }

    companion object {
        private const val TAG = "ErrorHandler"
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\utils\FrameExtractor.kt
==========================================

package com.roulette.tracker.utils

import android.graphics.Bitmap
import android.util.Log
import android.view.SurfaceView
import org.opencv.android.Utils
import org.opencv.core.Mat
import org.opencv.core.CvType
import org.opencv.imgproc.Imgproc

class FrameExtractor {
    fun extractFrame(surfaceView: SurfaceView): Mat? {
        try {
            // Screenshot des SurfaceView erstellen
            val bitmap = Bitmap.createBitmap(
                surfaceView.width,
                surfaceView.height,
                Bitmap.Config.ARGB_8888
            )
            
            // Bitmap zu OpenCV Mat konvertieren
            val frame = Mat(bitmap.height, bitmap.width, CvType.CV_8UC4)
            Utils.bitmapToMat(bitmap, frame)
            
            // Farbraum konvertieren
            Imgproc.cvtColor(frame, frame, Imgproc.COLOR_RGBA2BGR)
            
            return frame
        } catch (e: Exception) {
            Log.e("FrameExtractor", "Fehler bei Frame-Extraktion: ${e.message}")
            return null
        }
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\utils\OpenCVManager.kt
==========================================

package com.roulette.tracker.utils

import android.content.Context
import android.util.Log
import com.roulette.tracker.opencv.OpenCVInitializer
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

class OpenCVManager(private val context: Context) {
    private val initializer = OpenCVInitializer()
    
    suspend fun initialize(): Boolean = withContext(Dispatchers.Main) {
        try {
            initializer.initializeOpenCV(context)
        } catch (e: Exception) {
            Log.e(TAG, "Error initializing OpenCV: ${e.message}")
            false
        }
    }

    companion object {
        private const val TAG = "OpenCVManager"
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\utils\PermissionHandler.kt
==========================================

package com.roulette.tracker.utils

import android.Manifest
import android.app.Activity
import android.content.pm.PackageManager
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import android.widget.Toast

class PermissionHandler(private val activity: Activity) {
    
    fun checkAndRequestPermissions(): Boolean {
        val permissions = arrayOf(
            Manifest.permission.CAMERA
        )
        
        val permissionsToRequest = permissions.filter {
            ContextCompat.checkSelfPermission(activity, it) != PackageManager.PERMISSION_GRANTED
        }.toTypedArray()
        
        return if (permissionsToRequest.isNotEmpty()) {
            ActivityCompat.requestPermissions(activity, permissionsToRequest, PERMISSION_REQUEST_CODE)
            false
        } else {
            true
        }
    }

    fun handlePermissionResult(
        requestCode: Int,
        permissions: Array<out String>,
        grantResults: IntArray,
        onSuccess: () -> Unit,
        onFailure: () -> Unit
    ) {
        when (requestCode) {
            PERMISSION_REQUEST_CODE -> {
                if (grantResults.isNotEmpty() && 
                    grantResults.all { it == PackageManager.PERMISSION_GRANTED }) {
                    onSuccess()
                } else {
                    onFailure()
                }
            }
        }
    }

    companion object {
        private const val PERMISSION_REQUEST_CODE = 123
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\utils\PermissionManager.kt
==========================================

package com.roulette.tracker.utils

import android.Manifest
import android.app.Activity
import android.content.Context
import android.content.pm.PackageManager
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat

class PermissionManager(private val context: Context) {
    
    fun hasRequiredPermissions(): Boolean {
        return REQUIRED_PERMISSIONS.all {
            ContextCompat.checkSelfPermission(context, it) == PackageManager.PERMISSION_GRANTED
        }
    }

    fun requestPermissions(activity: Activity) {
        ActivityCompat.requestPermissions(
            activity,
            REQUIRED_PERMISSIONS,
            REQUEST_CODE_PERMISSIONS
        )
    }

    companion object {
        private val REQUIRED_PERMISSIONS = arrayOf(
            Manifest.permission.CAMERA,
            Manifest.permission.READ_EXTERNAL_STORAGE,
            Manifest.permission.WRITE_EXTERNAL_STORAGE
        )
        const val REQUEST_CODE_PERMISSIONS = 10
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\utils\ViewBindingDelegate.kt
==========================================

package com.roulette.tracker.utils

import android.view.View
import androidx.fragment.app.Fragment
import androidx.lifecycle.DefaultLifecycleObserver
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.LifecycleOwner
import androidx.viewbinding.ViewBinding
import kotlin.properties.ReadOnlyProperty
import kotlin.reflect.KProperty
import timber.log.Timber

class FragmentViewBindingDelegate<T : ViewBinding>(
    private val fragment: Fragment,
    private val bindingFactory: (View) -> T
) : ReadOnlyProperty<Fragment, T> {
    
    private var binding: T? = null
    
    init {
        setupLifecycleObserver()
    }

    override fun getValue(thisRef: Fragment, property: KProperty<*>): T {
        binding?.let { return it }

        check(fragment.viewLifecycleOwner.lifecycle.currentState.isAtLeast(Lifecycle.State.INITIALIZED)) {
            "Should not attempt to get bindings when Fragment views are destroyed."
        }

        return bindingFactory(thisRef.requireView()).also { 
            binding = it
            Timber.d("ViewBinding created for ${thisRef.javaClass.simpleName}")
        }
    }

    private fun setupLifecycleObserver() {
        fragment.lifecycle.addObserver(object : DefaultLifecycleObserver {
            override fun onCreate(owner: LifecycleOwner) {
                fragment.viewLifecycleOwnerLiveData.observe(fragment) { viewLifecycleOwner ->
                    viewLifecycleOwner.lifecycle.addObserver(object : DefaultLifecycleObserver {
                        override fun onDestroy(owner: LifecycleOwner) {
                            binding = null
                            Timber.d("ViewBinding cleared for ${fragment.javaClass.simpleName}")
                        }
                    })
                }
            }
        })
    }
}

fun <T : ViewBinding> Fragment.viewBinding(
    bindingFactory: (View) -> T
): FragmentViewBindingDelegate<T> = FragmentViewBindingDelegate(this, bindingFactory) 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\view\PredictionOverlayView.kt
==========================================

package com.roulette.tracker.view

import android.content.Context
import android.graphics.Canvas
import android.graphics.Color
import android.graphics.Paint
import android.graphics.Point
import android.util.AttributeSet
import android.view.LayoutInflater
import android.view.View
import android.widget.FrameLayout
import com.roulette.tracker.data.PredictionResult
import com.roulette.tracker.databinding.PredictionOverlayBinding

class PredictionOverlayView @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null,
    defStyleAttr: Int = 0
) : FrameLayout(context, attrs, defStyleAttr) {

    private var _binding: PredictionOverlayBinding? = null
    private val binding get() = _binding!!

    private var landingPosition: Point? = null
    private val paint = Paint().apply {
        color = Color.RED
        style = Paint.Style.FILL
        strokeWidth = 5f
    }

    init {
        _binding = PredictionOverlayBinding.inflate(
            LayoutInflater.from(context),
            this  // parent
        ).also { binding ->
            addView(binding.root)
        }
    }

    fun updatePrediction(prediction: PredictionResult) {
        binding.predictionNumberText.text = "Vorhersage: ${prediction.predictedNumber}"
        binding.confidenceBar.progress = (prediction.confidence * 100).toInt()
    }

    fun updateDebugInfo(ballVelocity: Double, wheelSpeed: Double) {
        binding.debugInfoText.text = """
            Ball: %.2f px/s
            Rad: %.2f Â°/s
        """.trimIndent().format(ballVelocity, wheelSpeed)
    }

    fun updateLandingPosition(position: Point) {
        landingPosition = position
        invalidate()
    }

    override fun onDraw(canvas: Canvas) {
        super.onDraw(canvas)
        landingPosition?.let { pos ->
            // Zeichne einen roten Punkt an der Landeposition
            canvas.drawCircle(pos.x.toFloat(), pos.y.toFloat(), 10f, paint)
        }
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\view\TrackingStatusView.kt
==========================================

package com.roulette.tracker.view

import android.content.Context
import android.util.AttributeSet
import android.view.LayoutInflater
import android.view.View
import android.widget.LinearLayout
import com.roulette.tracker.R
import com.roulette.tracker.data.PredictionResult
import com.roulette.tracker.data.TrackingState
import com.roulette.tracker.databinding.TrackingStatusViewBinding

class TrackingStatusView @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null,
    defStyleAttr: Int = 0
) : LinearLayout(context, attrs, defStyleAttr) {

    private var _binding: TrackingStatusViewBinding? = null
    private val binding get() = _binding!!

    init {
        _binding = TrackingStatusViewBinding.inflate(
            LayoutInflater.from(context),
            this  // parent
        ).also { binding ->
            addView(binding.root)
        }
    }

    fun updateState(state: TrackingState) {
        when (state) {
            is TrackingState.Initializing -> showInitializing()
            is TrackingState.Running -> showRunning()
            is TrackingState.Error -> showError(state.message)
            is TrackingState.BallNotFound -> showBallNotFound()
            is TrackingState.WheelNotFound -> showWheelNotFound()
            is TrackingState.Predicting -> showPredicting(state.timeRemaining)
            is TrackingState.Success -> showSuccess(state.prediction)
        }
    }

    private fun showInitializing() {
        binding.apply {
            statusText.text = context.getString(R.string.status_initializing)
            statusProgress.visibility = View.VISIBLE
            statusProgress.isIndeterminate = true
        }
    }

    private fun showRunning() {
        binding.apply {
            statusText.text = context.getString(R.string.status_running)
            statusProgress.visibility = View.VISIBLE
            statusProgress.isIndeterminate = false
            statusProgress.progress = 100
        }
    }

    private fun showError(message: String) {
        binding.apply {
            statusText.text = context.getString(R.string.status_error, message)
            statusProgress.visibility = View.GONE
        }
    }

    private fun showBallNotFound() {
        binding.apply {
            statusText.text = context.getString(R.string.status_ball_lost)
            statusProgress.visibility = View.GONE
        }
    }

    private fun showWheelNotFound() {
        binding.apply {
            statusText.text = context.getString(R.string.status_wheel_lost)
            statusProgress.visibility = View.GONE
        }
    }

    private fun showPredicting(timeRemaining: Long) {
        binding.apply {
            statusText.text = context.getString(
                R.string.status_predicting,
                timeRemaining / 1000
            )
            statusProgress.visibility = View.VISIBLE
            statusProgress.isIndeterminate = false
            statusProgress.progress = ((timeRemaining.toFloat() / 5000) * 100).toInt()
        }
    }

    private fun showSuccess(prediction: PredictionResult) {
        binding.apply {
            statusText.text = context.getString(
                R.string.status_prediction,
                prediction.predictedNumber,
                prediction.confidence * 100
            )
            statusProgress.visibility = View.GONE
        }
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\java\com\roulette\tracker\work\CleanupWorker.kt
==========================================

package com.roulette.tracker.work

import android.content.Context
import androidx.hilt.work.HiltWorker
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import com.roulette.tracker.data.repository.Repository
import com.roulette.tracker.data.entities.SimulationResult
import dagger.assisted.Assisted
import dagger.assisted.AssistedInject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import javax.inject.Inject

@HiltWorker
class CleanupWorker @AssistedInject constructor(
    @Assisted appContext: Context,
    @Assisted workerParams: WorkerParameters,
    private val repository: Repository<SimulationResult>
) : CoroutineWorker(appContext, workerParams) {

    override suspend fun doWork(): Result = withContext(Dispatchers.IO) {
        try {
            // LÃ¶sche alte Simulationsergebnisse
            val cutoffTime = System.currentTimeMillis() - RETENTION_PERIOD
            repository.deleteOlderThan(cutoffTime)
            Result.success()
        } catch (e: Exception) {
            Result.failure()
        }
    }

    companion object {
        private const val RETENTION_PERIOD = 30L * 24 * 60 * 60 * 1000 // 30 Tage
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\anim\nav_default_enter_anim.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android">
    <translate
        android:duration="@android:integer/config_mediumAnimTime"
        android:fromXDelta="100%"
        android:toXDelta="0%" />
</set> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\anim\nav_default_exit_anim.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android">
    <translate
        android:duration="@android:integer/config_mediumAnimTime"
        android:fromXDelta="0%"
        android:toXDelta="-100%" />
</set> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\anim\slide_in_left.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android">
    <translate
        android:duration="300"
        android:fromXDelta="-100%"
        android:toXDelta="0%" />
</set> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\anim\slide_in_right.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android">
    <translate
        android:duration="300"
        android:fromXDelta="100%"
        android:toXDelta="0%" />
</set> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\anim\slide_out_left.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android">
    <translate
        android:duration="300"
        android:fromXDelta="0%"
        android:toXDelta="-100%" />
</set> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\anim\slide_out_right.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android">
    <translate
        android:duration="300"
        android:fromXDelta="0%"
        android:toXDelta="100%" />
</set> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\drawable\chart_background.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android">
    <solid android:color="#FFFFFF"/>
    <corners android:radius="8dp"/>
    <stroke
        android:width="1dp"
        android:color="#CCCCCC"/>
</shape> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\drawable\ic_camera.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="?attr/colorControlNormal"
        android:pathData="M9.4,10.5l4.77,-8.26C13.47,2.09 12.75,2 12,2c-2.4,0 -4.6,0.85 -6.32,2.25l3.66,6.35 0.06,-0.1zM21.54,9c-0.92,-2.92 -3.15,-5.26 -6,-6.34L11.88,9h9.66zM21.8,10h-7.49l0.29,0.5 4.76,8.25C21,16.97 22,14.61 22,12c0,-0.69 -0.07,-1.35 -0.2,-2zM8.54,12l-3.9,-6.75C3.01,7.03 2,9.39 2,12c0,0.69 0.07,1.35 0.2,2h7.49l-1.15,-2zM2.46,15c0.92,2.92 3.15,5.26 6,6.34L12.12,15L2.46,15zM13.73,15l-3.9,6.76c0.7,0.15 1.42,0.24 2.17,0.24 2.4,0 4.6,-0.85 6.32,-2.25l-3.66,-6.35 -0.93,1.6z"/>
</vector> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\drawable\ic_launcher_background.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<vector
    android:height="108dp"
    android:width="108dp"
    android:viewportHeight="108"
    android:viewportWidth="108"
    xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="#3DDC84"
          android:pathData="M0,0h108v108h-108z"/>
    <path android:fillColor="#00000000" android:pathData="M9,0L9,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,0L19,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M29,0L29,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M39,0L39,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M49,0L49,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M59,0L59,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M69,0L69,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M79,0L79,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M89,0L89,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M99,0L99,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,9L108,9"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,19L108,19"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,29L108,29"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,39L108,39"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,49L108,49"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,59L108,59"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,69L108,69"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,79L108,79"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,89L108,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,99L108,99"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,29L89,29"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,39L89,39"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,49L89,49"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,59L89,59"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,69L89,69"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,79L89,79"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M29,19L29,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M39,19L39,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M49,19L49,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M59,19L59,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M69,19L69,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M79,19L79,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
</vector>

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\drawable\ic_launcher_foreground.xml
==========================================

<vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="108"
    android:viewportHeight="108">
  <group android:scaleX="0.699403"
      android:scaleY="0.699403"
      android:translateX="8.888508"
      android:translateY="3.9926865">
      <path
          android:pathData="M31,63.928c0,0 6.4,-11 12.1,-13.1c7.2,-2.6 26,-1.4 26,-1.4l38.1,38.1L107,108.928l-32,-1L31,63.928z">
          <aapt:attr name="android:fillColor">
              <gradient
                  android:startY="49.59793"
                  android:startX="42.9492"
                  android:endY="92.4963"
                  android:endX="85.84757"
                  android:type="linear">
                  <item
                      android:color="#44000000"
                      android:offset="0.0" />
                  <item
                      android:color="#00000000"
                      android:offset="1.0" />
              </gradient>
          </aapt:attr>
      </path>
      <path
          android:pathData="M65.3,45.828l3.8,-6.6c0.2,-0.4 0.1,-0.9 -0.3,-1.1c-0.4,-0.2 -0.9,-0.1 -1.1,0.3l-3.9,6.7c-6.3,-2.8 -13.4,-2.8 -19.7,0l-3.9,-6.7c-0.2,-0.4 -0.7,-0.5 -1.1,-0.3C38.8,38.328 38.7,38.828 38.9,39.228l3.8,6.6C36.2,49.428 31.7,56.028 31,63.928h46C76.3,56.028 71.8,49.428 65.3,45.828zM43.4,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2c-0.3,-0.7 -0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C45.3,56.528 44.5,57.328 43.4,57.328L43.4,57.328zM64.6,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2s-0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C66.5,56.528 65.6,57.328 64.6,57.328L64.6,57.328z"
          android:fillColor="#FFFFFF"
          android:fillType="nonZero"
          android:strokeWidth="1"
          android:strokeColor="#00000000"/>
  </group>
</vector>

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\drawable\ic_play.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="?attr/colorControlNormal"
        android:pathData="M8,5v14l11,-7z"/>
</vector> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\drawable\ic_settings.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="?attr/colorControlNormal"
        android:pathData="M19.14,12.94c0.04,-0.3 0.06,-0.61 0.06,-0.94c0,-0.32 -0.02,-0.64 -0.07,-0.94l2.03,-1.58c0.18,-0.14 0.23,-0.41 0.12,-0.61l-1.92,-3.32c-0.12,-0.22 -0.37,-0.29 -0.59,-0.22l-2.39,0.96c-0.5,-0.38 -1.03,-0.7 -1.62,-0.94L14.4,2.81c-0.04,-0.24 -0.24,-0.41 -0.48,-0.41h-3.84c-0.24,0 -0.43,0.17 -0.47,0.41L9.25,5.35C8.66,5.59 8.12,5.92 7.63,6.29L5.24,5.33c-0.22,-0.08 -0.47,0 -0.59,0.22L2.74,8.87C2.62,9.08 2.66,9.34 2.86,9.48l2.03,1.58C4.84,11.36 4.8,11.69 4.8,12s0.02,0.64 0.07,0.94l-2.03,1.58c-0.18,0.14 -0.23,0.41 -0.12,0.61l1.92,3.32c0.12,0.22 0.37,0.29 0.59,0.22l2.39,-0.96c0.5,0.38 1.03,0.7 1.62,0.94l0.36,2.54c0.05,0.24 0.24,0.41 0.48,0.41h3.84c0.24,0 0.44,-0.17 0.47,-0.41l0.36,-2.54c0.59,-0.24 1.13,-0.56 1.62,-0.94l2.39,0.96c0.22,0.08 0.47,0 0.59,-0.22l1.92,-3.32c0.12,-0.22 0.07,-0.47 -0.12,-0.61L19.14,12.94zM12,15.6c-1.98,0 -3.6,-1.62 -3.6,-3.6s1.62,-3.6 3.6,-3.6s3.6,1.62 3.6,3.6S13.98,15.6 12,15.6z"/>
</vector> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\drawable\ic_stats.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="?attr/colorControlNormal"
        android:pathData="M19,3L5,3c-1.1,0 -2,0.9 -2,2v14c0,1.1 0.9,2 2,2h14c1.1,0 2,-0.9 2,-2L21,5c0,-1.1 -0.9,-2 -2,-2zM9,17L7,17v-7h2v7zM13,17h-2L11,7h2v10zM17,17h-2v-4h2v4z"/>
</vector> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\drawable\ic_stop.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="?attr/colorControlNormal"
        android:pathData="M6,6h12v12H6z"/>
</vector> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\drawable\ic_tracking.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="?attr/colorControlNormal"
        android:pathData="M12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM12,20c-4.41,0 -8,-3.59 -8,-8s3.59,-8 8,-8 8,3.59 8,8 -3.59,8 -8,8zM12,7c-2.76,0 -5,2.24 -5,5s2.24,5 5,5 5,-2.24 5,-5 -2.24,-5 -5,-5z"/>
</vector> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\layout\activity_main.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <androidx.appcompat.widget.Toolbar
        android:id="@+id/toolbar"
        android:layout_width="match_parent"
        android:layout_height="?attr/actionBarSize"
        android:background="?attr/colorPrimary"
        android:elevation="4dp"
        android:theme="@style/ThemeOverlay.AppCompat.ActionBar"
        app:layout_constraintTop_toTopOf="parent"
        app:popupTheme="@style/ThemeOverlay.AppCompat.Light" />

    <androidx.fragment.app.FragmentContainerView
        android:id="@+id/nav_host_fragment"
        android:name="androidx.navigation.fragment.NavHostFragment"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        app:defaultNavHost="true"
        app:layout_constraintBottom_toTopOf="@id/bottom_navigation"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toBottomOf="@id/toolbar"
        app:navGraph="@navigation/nav_graph" />

    <com.google.android.material.bottomnavigation.BottomNavigationView
        android:id="@+id/bottom_navigation"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_gravity="bottom"
        app:layout_constraintBottom_toBottomOf="parent"
        app:menu="@menu/bottom_nav_menu" />

</androidx.constraintlayout.widget.ConstraintLayout> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\layout\activity_settings.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:padding="16dp">

        <!-- Kessel-Parameter -->
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Kessel-Parameter"
            android:textStyle="bold"
            android:textSize="18sp"
            android:layout_marginBottom="8dp"/>

        <EditText
            android:id="@+id/wheelDiameter"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:hint="Kessel-Durchmesser (mm)"
            android:inputType="numberDecimal"/>

        <EditText
            android:id="@+id/ballDiameter"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:hint="Ball-Durchmesser (mm)"
            android:inputType="numberDecimal"/>

        <EditText
            android:id="@+id/numberSpacing"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:hint="Abstand zwischen Zahlen (mm)"
            android:inputType="numberDecimal"/>

        <!-- Tracking-Parameter -->
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Tracking-Parameter"
            android:textStyle="bold"
            android:textSize="18sp"
            android:layout_marginTop="16dp"
            android:layout_marginBottom="8dp"/>

        <EditText
            android:id="@+id/minTrackingFrames"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:hint="Minimale Tracking-Frames"
            android:inputType="number"/>

        <EditText
            android:id="@+id/predictionWindow"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:hint="Vorhersage-Fenster (Frames)"
            android:inputType="number"/>
    </LinearLayout>
</ScrollView> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\layout\activity_statistics.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<androidx.swiperefreshlayout.widget.SwipeRefreshLayout
    android:id="@+id/swipeRefresh"
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <ScrollView
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:padding="16dp">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Genauigkeitsverlauf"
                android:textStyle="bold"
                android:textSize="18sp"/>

            <com.github.mikephil.charting.charts.LineChart
                android:id="@+id/accuracyChart"
                android:layout_width="match_parent"
                android:layout_height="250dp"
                android:layout_marginTop="8dp"
                android:layout_marginBottom="16dp"
                android:background="@drawable/chart_background"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Vorhersagen vs. TatsÃ¤chliche Zahlen"
                android:textStyle="bold"
                android:textSize="18sp"/>

            <com.github.mikephil.charting.charts.LineChart
                android:id="@+id/predictionChart"
                android:layout_width="match_parent"
                android:layout_height="250dp"
                android:layout_marginTop="8dp"
                android:layout_marginBottom="16dp"
                android:background="@drawable/chart_background"/>

            <androidx.cardview.widget.CardView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="8dp"
                app:cardCornerRadius="8dp"
                app:cardElevation="4dp">

                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="vertical"
                    android:padding="16dp">

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Detaillierte Statistiken"
                        android:textStyle="bold"
                        android:textSize="18sp"/>

                    <TextView
                        android:id="@+id/stats100"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:layout_marginTop="8dp"
                        android:textSize="14sp"/>

                    <TextView
                        android:id="@+id/stats1000"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:layout_marginTop="16dp"
                        android:textSize="14sp"/>

                    <TextView
                        android:id="@+id/extendedStats"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:layout_marginTop="16dp"
                        android:textSize="14sp"/>

                </LinearLayout>

            </androidx.cardview.widget.CardView>

            <Spinner
                android:id="@+id/timeRangeSpinner"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="8dp"
                android:layout_marginBottom="16dp"/>

        </LinearLayout>

    </ScrollView>

</androidx.swiperefreshlayout.widget.SwipeRefreshLayout> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\layout\activity_tracking.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <androidx.camera.view.PreviewView
        android:id="@+id/previewView"
        android:layout_width="0dp"
        android:layout_height="0dp"
        app:layout_constraintBottom_toTopOf="@+id/debugPreview"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintHeight_percent="0.5" />

    <VideoView
        android:id="@+id/videoView"
        android:layout_width="0dp"
        android:layout_height="0dp"
        android:visibility="gone"
        app:layout_constraintBottom_toTopOf="@+id/debugPreview"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintHeight_percent="0.5" />

    <ImageView
        android:id="@+id/debugPreview"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/previewView"
        app:layout_constraintHeight_percent="0.5" />

    <com.roulette.tracker.view.TrackingStatusView
        android:id="@+id/trackingStatus"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_margin="16dp"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />

    <com.roulette.tracker.view.PredictionOverlayView
        android:id="@+id/predictionOverlay"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_margin="16dp"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintBottom_toTopOf="@+id/debugPreview" />

</androidx.constraintlayout.widget.ConstraintLayout> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\layout\dialog_number_input.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="16dp">

    <EditText
        android:id="@+id/numberInput"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:inputType="number"
        android:hint="@string/enter_number" />

</LinearLayout> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\layout\dialog_number_verification.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="16dp">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Ergebnis Ã¼berprÃ¼fen"
        android:textAppearance="?attr/textAppearanceHeadline6"
        android:layout_marginBottom="16dp"/>

    <TextView
        android:id="@+id/predictedNumberText"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:textAppearance="?attr/textAppearanceBody1"
        android:layout_marginBottom="16dp"/>

    <com.google.android.material.textfield.TextInputLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:hint="TatsÃ¤chliche Nummer (0-36)">

        <com.google.android.material.textfield.TextInputEditText
            android:id="@+id/actualNumberInput"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:inputType="number"
            android:maxLength="2"/>

    </com.google.android.material.textfield.TextInputLayout>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="end"
        android:layout_marginTop="16dp">

        <com.google.android.material.button.MaterialButton
            android:id="@+id/skipButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Ãœberspringen"
            style="@style/Widget.MaterialComponents.Button.TextButton"/>

        <com.google.android.material.button.MaterialButton
            android:id="@+id/confirmButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="BestÃ¤tigen"
            android:layout_marginStart="8dp"
            android:enabled="false"/>

    </LinearLayout>

</LinearLayout> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\layout\fragment_live_tracking.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <androidx.camera.view.PreviewView
        android:id="@+id/previewView"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toTopOf="@id/controlsCard"/>

    <ImageView
        android:id="@+id/debugOverlayView"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        app:layout_constraintTop_toTopOf="@id/previewView"
        app:layout_constraintBottom_toBottomOf="@id/previewView"/>

    <com.google.android.material.card.MaterialCardView
        android:id="@+id/predictionCard"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_margin="16dp"
        android:visibility="gone"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

        <LinearLayout
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:padding="16dp">

            <TextView
                android:id="@+id/predictionText"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:textSize="18sp"/>

            <TextView
                android:id="@+id/confidenceText"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"/>

            <TextView
                android:id="@+id/timeToLandingText"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"/>

        </LinearLayout>

    </com.google.android.material.card.MaterialCardView>

    <com.google.android.material.card.MaterialCardView
        android:id="@+id/controlsCard"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        app:layout_constraintBottom_toBottomOf="parent">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:padding="16dp">

            <TextView
                android:id="@+id/statusText"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Bereit"/>

            <TextView
                android:id="@+id/fpsText"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="0 FPS"/>

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="horizontal"
                android:gravity="center_vertical"
                android:layout_marginTop="8dp">

                <com.google.android.material.button.MaterialButton
                    android:id="@+id/startTrackingButton"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="Start"/>

                <Space
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:layout_weight="1"/>

                <com.google.android.material.switchmaterial.SwitchMaterial
                    android:id="@+id/debugSwitch"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="Debug"/>

            </LinearLayout>

            <com.google.android.material.button.MaterialButton
                android:id="@+id/statsButton"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="Statistiken anzeigen"
                android:layout_marginTop="8dp"
                style="@style/Widget.MaterialComponents.Button.OutlinedButton"/>

        </LinearLayout>

    </com.google.android.material.card.MaterialCardView>

</androidx.constraintlayout.widget.ConstraintLayout> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\layout\fragment_live_tracking_stats.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:padding="16dp">

    <com.github.mikephil.charting.charts.BarChart
        android:id="@+id/accuracyPerNumberChart"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1" />

    <com.github.mikephil.charting.charts.LineChart
        android:id="@+id/predictionTimeChart"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1" />

    <Button
        android:id="@+id/exportButton"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Statistiken exportieren" />

</LinearLayout> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\layout\fragment_main.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <TextureView
        android:id="@+id/textureView"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />

    <com.google.android.material.floatingactionbutton.FloatingActionButton
        android:id="@+id/fabCapture"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_margin="16dp"
        android:src="@drawable/ic_camera"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent" />

</androidx.constraintlayout.widget.ConstraintLayout> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\layout\fragment_results.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:padding="16dp">

        <com.google.android.material.chip.ChipGroup
            android:id="@+id/timeRangeChips"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center_horizontal"
            app:singleSelection="true">

            <com.google.android.material.chip.Chip
                android:id="@+id/chip_day"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="24h"/>

            <com.google.android.material.chip.Chip
                android:id="@+id/chip_week"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="7 Tage"
                android:checked="true"/>

            <com.google.android.material.chip.Chip
                android:id="@+id/chip_month"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="30 Tage"/>

            <com.google.android.material.chip.Chip
                android:id="@+id/chip_all"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Alle"/>

        </com.google.android.material.chip.ChipGroup>

        <com.google.android.material.card.MaterialCardView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="16dp">

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="vertical"
                android:padding="16dp">

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="Zusammenfassung"
                    android:textAppearance="?attr/textAppearanceHeadline6"/>

                <TextView
                    android:id="@+id/totalSimulationsText"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="8dp"/>

                <TextView
                    android:id="@+id/successRateText"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="4dp"/>

                <TextView
                    android:id="@+id/averageConfidenceText"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="4dp"/>

                <TextView
                    android:id="@+id/averageTimeText"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="4dp"/>

            </LinearLayout>

        </com.google.android.material.card.MaterialCardView>

        <com.github.mikephil.charting.charts.PieChart
            android:id="@+id/numberDistributionChart"
            android:layout_width="match_parent"
            android:layout_height="300dp"
            android:layout_marginTop="16dp"/>

        <com.github.mikephil.charting.charts.LineChart
            android:id="@+id/successRateChart"
            android:layout_width="match_parent"
            android:layout_height="200dp"
            android:layout_marginTop="16dp"/>

        <com.github.mikephil.charting.charts.LineChart
            android:id="@+id/confidenceChart"
            android:layout_width="match_parent"
            android:layout_height="200dp"
            android:layout_marginTop="16dp"/>

    </LinearLayout>

</ScrollView> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\layout\fragment_settings.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:padding="@dimen/padding_large">

        <!-- QualitÃ¤tseinstellungen -->
        <com.google.android.material.card.MaterialCardView
            style="@style/CardStyle"
            android:layout_width="match_parent"
            android:layout_height="wrap_content">

            <LinearLayout
                style="@style/CardContent"
                android:layout_width="match_parent"
                android:layout_height="wrap_content">

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/quality_settings"
                    android:textAppearance="?attr/textAppearanceHeadline6" />

                <com.google.android.material.switchmaterial.SwitchMaterial
                    android:id="@+id/highQualitySwitch"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="@dimen/margin_medium"
                    android:text="@string/high_quality_mode" />

            </LinearLayout>

        </com.google.android.material.card.MaterialCardView>

        <!-- Erkennungseinstellungen -->
        <com.google.android.material.card.MaterialCardView
            style="@style/CardStyle"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="@dimen/margin_medium">

            <LinearLayout
                style="@style/CardContent"
                android:layout_width="match_parent"
                android:layout_height="wrap_content">

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/detection_settings"
                    android:textAppearance="?attr/textAppearanceHeadline6" />

                <com.google.android.material.switchmaterial.SwitchMaterial
                    android:id="@+id/roiSwitch"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="@dimen/margin_medium"
                    android:text="@string/enable_roi" />

                <TextView
                    android:id="@+id/confidenceLabel"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="@dimen/margin_medium" />

                <com.google.android.material.slider.Slider
                    android:id="@+id/confidenceSlider"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:valueFrom="0.0"
                    android:valueTo="1.0"
                    android:stepSize="0.05" />

                <TextView
                    android:id="@+id/predictionDelayLabel"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="@dimen/margin_medium" />

                <com.google.android.material.slider.Slider
                    android:id="@+id/predictionDelaySlider"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:valueFrom="1"
                    android:valueTo="10"
                    android:stepSize="1" />

            </LinearLayout>

        </com.google.android.material.card.MaterialCardView>

        <!-- Sonstige Einstellungen -->
        <com.google.android.material.card.MaterialCardView
            style="@style/CardStyle"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="@dimen/margin_medium">

            <LinearLayout
                style="@style/CardContent"
                android:layout_width="match_parent"
                android:layout_height="wrap_content">

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/other_settings"
                    android:textAppearance="?attr/textAppearanceHeadline6" />

                <com.google.android.material.switchmaterial.SwitchMaterial
                    android:id="@+id/autoSaveSwitch"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="@dimen/margin_medium"
                    android:text="@string/auto_save" />

                <com.google.android.material.switchmaterial.SwitchMaterial
                    android:id="@+id/debugModeSwitch"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:text="@string/debug_mode" />

                <com.google.android.material.switchmaterial.SwitchMaterial
                    android:id="@+id/voiceSwitch"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:text="@string/voice_enabled" />

            </LinearLayout>

        </com.google.android.material.card.MaterialCardView>

    </LinearLayout>

</ScrollView> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\layout\fragment_simulation.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:padding="16dp">

    <FrameLayout
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1">

        <ImageView
            android:id="@+id/previewImageView"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:scaleType="centerInside"/>

        <ImageView
            android:id="@+id/debugOverlayView"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:scaleType="centerInside"/>

    </FrameLayout>

    <com.google.android.material.card.MaterialCardView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginTop="8dp"
        android:layout_marginBottom="8dp">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:padding="16dp">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Analyse-Ergebnisse"
                android:textAppearance="?attr/textAppearanceHeadline6"/>

            <TextView
                android:id="@+id/predictionText"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginTop="8dp"
                android:text="Keine Vorhersage"/>

            <TextView
                android:id="@+id/confidenceText"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginTop="4dp"
                android:text="Konfidenz: 0%"/>

            <TextView
                android:id="@+id/timeToLandingText"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginTop="4dp"
                android:text="Zeit bis zur Landung: --"/>

        </LinearLayout>

    </com.google.android.material.card.MaterialCardView>

    <com.google.android.material.card.MaterialCardView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginTop="16dp">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:padding="16dp">

            <com.google.android.material.slider.Slider
                android:id="@+id/progressSlider"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:valueFrom="0"
                android:valueTo="100"/>

            <TextView
                android:id="@+id/timeText"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center"
                android:text="00:00 / 00:00"/>

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="horizontal"
                android:gravity="center"
                android:layout_marginTop="8dp">

                <com.google.android.material.button.MaterialButton
                    android:id="@+id/loadVideoButton"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="Video laden"/>

                <com.google.android.material.button.MaterialButton
                    android:id="@+id/playButton"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginStart="8dp"
                    android:text="Play"/>

            </LinearLayout>

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="horizontal"
                android:gravity="center_vertical"
                android:layout_marginTop="8dp">

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="Geschwindigkeit:"/>

                <com.google.android.material.slider.Slider
                    android:id="@+id/speedSlider"
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:layout_weight="1"
                    android:valueFrom="0.25"
                    android:valueTo="2.0"
                    android:stepSize="0.25"/>

                <TextView
                    android:id="@+id/speedText"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="1.0x"/>

            </LinearLayout>

        </LinearLayout>

    </com.google.android.material.card.MaterialCardView>

    <com.google.android.material.card.MaterialCardView
        android:id="@+id/statsCard"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginTop="16dp"
        android:layout_marginBottom="16dp"
        app:layout_constraintTop_toBottomOf="@id/controlsCard">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:padding="16dp">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Statistiken"
                android:textAppearance="?attr/textAppearanceHeadline6"/>

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="horizontal"
                android:layout_marginTop="8dp">

                <TextView
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:layout_weight="1"
                    android:text="Gesamtvorhersagen:"/>

                <TextView
                    android:id="@+id/totalPredictionsText"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:textStyle="bold"/>

            </LinearLayout>

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="horizontal"
                android:layout_marginTop="4dp">

                <TextView
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:layout_weight="1"
                    android:text="Erfolgsquote:"/>

                <TextView
                    android:id="@+id/successRateText"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:textStyle="bold"/>

            </LinearLayout>

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="horizontal"
                android:layout_marginTop="4dp">

                <TextView
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:layout_weight="1"
                    android:text="Durchschnittliche Konfidenz:"/>

                <TextView
                    android:id="@+id/avgConfidenceText"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:textStyle="bold"/>

            </LinearLayout>

            <com.google.android.material.button.MaterialButton
                android:id="@+id/showDetailsButton"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="Details anzeigen"
                android:layout_marginTop="8dp"
                style="@style/Widget.MaterialComponents.Button.OutlinedButton"/>

        </LinearLayout>

    </com.google.android.material.card.MaterialCardView>

</LinearLayout> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\layout\fragment_simulation_stats.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:padding="16dp">

        <com.google.android.material.chip.ChipGroup
            android:id="@+id/timeRangeChips"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginBottom="16dp"
            app:singleSelection="true">

            <com.google.android.material.chip.Chip
                android:id="@+id/chip_day"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="24 Stunden"/>

            <com.google.android.material.chip.Chip
                android:id="@+id/chip_week"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="7 Tage"
                android:checked="true"/>

            <com.google.android.material.chip.Chip
                android:id="@+id/chip_month"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="30 Tage"/>

            <com.google.android.material.chip.Chip
                android:id="@+id/chip_all"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Alle"/>

        </com.google.android.material.chip.ChipGroup>

        <com.google.android.material.card.MaterialCardView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginBottom="16dp">

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="vertical"
                android:padding="16dp">

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="Zusammenfassung"
                    android:textAppearance="?attr/textAppearanceHeadline6"/>

                <GridLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:columnCount="2"
                    android:rowCount="5"
                    android:layout_marginTop="8dp">

                    <TextView
                        android:layout_width="0dp"
                        android:layout_height="wrap_content"
                        android:layout_columnWeight="1"
                        android:text="Gesamtvorhersagen:"/>

                    <TextView
                        android:id="@+id/totalPredictionsText"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:textStyle="bold"/>

                    <TextView
                        android:layout_width="0dp"
                        android:layout_height="wrap_content"
                        android:layout_columnWeight="1"
                        android:text="Erfolgsquote:"/>

                    <TextView
                        android:id="@+id/successRateText"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:textStyle="bold"/>

                    <TextView
                        android:layout_width="0dp"
                        android:layout_height="wrap_content"
                        android:layout_columnWeight="1"
                        android:text="Durchschnittliche Konfidenz:"/>

                    <TextView
                        android:id="@+id/avgConfidenceText"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:textStyle="bold"/>

                    <TextView
                        android:layout_width="0dp"
                        android:layout_height="wrap_content"
                        android:layout_columnWeight="1"
                        android:text="Beste Nummer:"/>

                    <TextView
                        android:id="@+id/bestNumberText"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:textStyle="bold"/>

                    <TextView
                        android:layout_width="0dp"
                        android:layout_height="wrap_content"
                        android:layout_columnWeight="1"
                        android:text="Schlechteste Nummer:"/>

                    <TextView
                        android:id="@+id/worstNumberText"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:textStyle="bold"/>

                </GridLayout>

            </LinearLayout>

        </com.google.android.material.card.MaterialCardView>

        <com.github.mikephil.charting.charts.LineChart
            android:id="@+id/successRateChart"
            android:layout_width="match_parent"
            android:layout_height="200dp"
            android:layout_marginBottom="16dp"/>

        <com.github.mikephil.charting.charts.BarChart
            android:id="@+id/confidenceDistributionChart"
            android:layout_width="match_parent"
            android:layout_height="200dp"
            android:layout_marginBottom="16dp"/>

        <com.github.mikephil.charting.charts.BarChart
            android:id="@+id/accuracyPerNumberChart"
            android:layout_width="match_parent"
            android:layout_height="200dp"/>

    </LinearLayout>

</ScrollView> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\layout\fragment_statistics.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:padding="16dp">

        <com.google.android.material.card.MaterialCardView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginBottom="16dp">

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="vertical"
                android:padding="16dp">

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="Zusammenfassung"
                    android:textAppearance="?attr/textAppearanceHeadline6"/>

                <TextView
                    android:id="@+id/successRateText"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="8dp"
                    android:text="Erfolgsrate: 0%"/>

                <TextView
                    android:id="@+id/averageConfidenceText"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="4dp"
                    android:text="Durchschnittliche Konfidenz: 0%"/>

                <TextView
                    android:id="@+id/totalPredictionsText"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="4dp"
                    android:text="Gesamtvorhersagen: 0"/>

            </LinearLayout>

        </com.google.android.material.card.MaterialCardView>

        <com.github.mikephil.charting.charts.LineChart
            android:id="@+id/successRateChart"
            android:layout_width="match_parent"
            android:layout_height="200dp"
            android:layout_marginBottom="16dp"/>

        <com.github.mikephil.charting.charts.PieChart
            android:id="@+id/numberFrequencyChart"
            android:layout_width="match_parent"
            android:layout_height="200dp"/>

    </LinearLayout>

</ScrollView> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\layout\fragment_stats.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:padding="@dimen/padding_large">

        <com.google.android.material.card.MaterialCardView
            style="@style/CardStyle"
            android:layout_width="match_parent"
            android:layout_height="wrap_content">

            <LinearLayout
                style="@style/CardContent"
                android:layout_width="match_parent"
                android:layout_height="wrap_content">

                <TextView
                    android:id="@+id/title"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/stats"
                    android:textSize="24sp"
                    android:textStyle="bold"
                    android:layout_marginTop="16dp"/>

                <com.google.android.material.chip.ChipGroup
                    android:id="@+id/timeRangeGroup"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="@dimen/margin_medium"
                    app:singleSelection="true">

                    <com.google.android.material.chip.Chip
                        android:id="@+id/lastHourButton"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="@string/last_hour" />

                    <com.google.android.material.chip.Chip
                        android:id="@+id/todayButton"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="@string/today" />

                    <com.google.android.material.chip.Chip
                        android:id="@+id/lastWeekButton"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="@string/last_week" />

                    <com.google.android.material.chip.Chip
                        android:id="@+id/allTimeButton"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="@string/all_time" />

                </com.google.android.material.chip.ChipGroup>

                <TextView
                    android:id="@+id/totalPredictionsText"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="@dimen/margin_medium"
                    android:textAppearance="?attr/textAppearanceBody1" />

                <TextView
                    android:id="@+id/successfulPredictionsText"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="@dimen/margin_small"
                    android:textAppearance="?attr/textAppearanceBody1" />

                <TextView
                    android:id="@+id/successRateText"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="@dimen/margin_small"
                    android:textAppearance="?attr/textAppearanceBody1" />

                <TextView
                    android:id="@+id/averageConfidenceText"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="@dimen/margin_small"
                    android:textAppearance="?attr/textAppearanceBody1" />

                <TextView
                    android:id="@+id/averageTimeToLandingText"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="@dimen/margin_small"
                    android:textAppearance="?attr/textAppearanceBody1" />

                <TextView
                    android:id="@+id/trendText"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="@dimen/margin_small"
                    android:textAppearance="?attr/textAppearanceBody1" />

            </LinearLayout>

        </com.google.android.material.card.MaterialCardView>

        <com.github.mikephil.charting.charts.LineChart
            android:id="@+id/confidenceChart"
            style="@style/ChartStyle"
            android:layout_width="match_parent"
            android:layout_height="@dimen/chart_height" />

        <com.github.mikephil.charting.charts.LineChart
            android:id="@+id/timeToLandingChart"
            style="@style/ChartStyle"
            android:layout_width="match_parent"
            android:layout_height="@dimen/chart_height" />

    </LinearLayout>

</ScrollView> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\layout\fragment_tracking.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <com.google.android.material.card.MaterialCardView
        android:id="@+id/previewCard"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_margin="@dimen/margin_medium"
        app:cardCornerRadius="@dimen/card_corner_radius"
        app:cardElevation="@dimen/card_elevation"
        app:layout_constraintBottom_toTopOf="@id/controlPanel"
        app:layout_constraintTop_toTopOf="parent">

        <FrameLayout
            android:layout_width="match_parent"
            android:layout_height="match_parent">

            <org.opencv.android.JavaCameraView
                android:id="@+id/cameraView"
                android:layout_width="match_parent"
                android:layout_height="match_parent" />

            <TextView
                android:id="@+id/statusText"
                style="@style/TrackingStatusText"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_gravity="top" />

            <ProgressBar
                android:id="@+id/progressBar"
                style="@style/TrackingStatusProgress"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_gravity="top"
                android:visibility="gone" />

            <TextView
                android:id="@+id/predictionText"
                style="@style/TrackingStatusText"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_gravity="bottom"
                android:visibility="gone" />
        </FrameLayout>

    </com.google.android.material.card.MaterialCardView>

    <com.google.android.material.card.MaterialCardView
        android:id="@+id/controlPanel"
        style="@style/CardStyle"
        android:layout_margin="@dimen/margin_medium"
        app:layout_constraintBottom_toBottomOf="parent">

        <LinearLayout
            style="@style/CardContent"
            android:gravity="center_vertical">

            <com.google.android.material.button.MaterialButtonToggleGroup
                android:id="@+id/toggleGroup"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                app:singleSelection="true">

                <Button
                    android:id="@+id/btnLive"
                    style="@style/Widget.MaterialComponents.Button.OutlinedButton"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/toggle_stream" />

                <Button
                    android:id="@+id/btnFile"
                    style="@style/Widget.MaterialComponents.Button.OutlinedButton"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/toggle_video" />

            </com.google.android.material.button.MaterialButtonToggleGroup>

            <Space
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1" />

            <com.google.android.material.floatingactionbutton.FloatingActionButton
                android:id="@+id/btnStartStop"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/ic_play"
                app:fabSize="normal" />

        </LinearLayout>

    </com.google.android.material.card.MaterialCardView>

</androidx.constraintlayout.widget.ConstraintLayout> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\layout\prediction_overlay.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<merge xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    tools:parentTag="android.widget.FrameLayout">

    <LinearLayout
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:padding="16dp"
        android:background="#80000000">

        <TextView
            android:id="@+id/debugInfoText"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textColor="@android:color/white"
            android:textSize="12sp"
            tools:text="Debug Info" />

        <TextView
            android:id="@+id/predictionNumberText"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginTop="8dp"
            android:textColor="@android:color/white"
            android:textSize="16sp"
            android:textStyle="bold"
            tools:text="Vorhersage: 0" />

        <ProgressBar
            android:id="@+id/confidenceBar"
            style="?android:attr/progressBarStyleHorizontal"
            android:layout_width="100dp"
            android:layout_height="wrap_content"
            android:layout_marginTop="4dp" />

    </LinearLayout>

</merge> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\layout\tracking_status_view.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<merge xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    tools:parentTag="android.widget.LinearLayout">

    <TextView
        android:id="@+id/statusText"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:textColor="@android:color/white"
        android:textSize="16sp"
        tools:text="Status" />

    <ProgressBar
        android:id="@+id/statusProgress"
        style="?android:attr/progressBarStyleHorizontal"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginTop="8dp" />

</merge> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\menu\bottom_nav_menu.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">
    <item
        android:id="@+id/navigation_tracking"
        android:icon="@drawable/ic_tracking"
        android:title="@string/tracking" />

    <item
        android:id="@+id/navigation_stats"
        android:icon="@drawable/ic_stats"
        android:title="@string/stats" />

    <item
        android:id="@+id/settingsFragment"
        android:icon="@drawable/ic_settings"
        android:title="@string/settings" />
</menu> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\menu\main_menu.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">
    
    <item
        android:id="@+id/action_settings"
        android:title="@string/settings"
        android:orderInCategory="100"
        app:showAsAction="never"/>

</menu> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\mipmap-anydpi-v26\ic_launcher.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background"/>
    <foreground android:drawable="@drawable/ic_launcher_foreground"/>
</adaptive-icon>

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\mipmap-anydpi-v26\ic_launcher_round.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background"/>
    <foreground android:drawable="@drawable/ic_launcher_foreground"/>
</adaptive-icon>

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\navigation\nav_graph.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<navigation xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/nav_graph"
    app:startDestination="@id/trackingFragment">

    <fragment
        android:id="@+id/trackingFragment"
        android:name="com.roulette.tracker.ui.tracking.TrackingFragment"
        android:label="@string/tracking">
        <action
            android:id="@+id/action_tracking_to_stats"
            app:destination="@id/statsFragment">
            <argument
                android:name="sessionId"
                app:argType="long" />
        </action>
    </fragment>

    <fragment
        android:id="@+id/statsFragment"
        android:name="com.roulette.tracker.ui.stats.StatsFragment"
        android:label="@string/stats">
        <argument
            android:name="sessionId"
            app:argType="long" />
    </fragment>

    <fragment
        android:id="@+id/navigation_settings"
        android:name="com.roulette.tracker.ui.settings.SettingsFragment"
        android:label="@string/settings" />

</navigation> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\values\colors.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Material Design Colors -->
    <color name="purple_200">#FFBB86FC</color>
    <color name="purple_500">#FF6200EE</color>
    <color name="purple_700">#FF3700B3</color>
    <color name="teal_200">#FF03DAC5</color>
    <color name="teal_700">#FF018786</color>
    
    <!-- Neutral Colors -->
    <color name="white">#FFFFFFFF</color>
    <color name="black">#FF000000</color>
    <color name="gray_50">#FAFAFA</color>
    <color name="gray_100">#F5F5F5</color>
    <color name="gray_200">#EEEEEE</color>
    <color name="gray_300">#E0E0E0</color>
    <color name="gray_400">#BDBDBD</color>
    <color name="gray_500">#9E9E9E</color>
    <color name="gray_600">#757575</color>
    <color name="gray_700">#616161</color>
    <color name="gray_800">#424242</color>
    <color name="gray_900">#212121</color>
    
    <!-- Background Colors -->
    <color name="background">#FFFFFFFF</color>
    <color name="background_dark">#121212</color>
    <color name="surface">#FFFFFFFF</color>
    <color name="surface_dark">#1E1E1E</color>
    
    <!-- Status Colors -->
    <color name="status_success">#FF4CAF50</color>
    <color name="status_warning">#FFFFEB3B</color>
    <color name="status_error">#FFF44336</color>
    <color name="error">#F44336</color>
    <color name="error_dark">#D32F2F</color>
    
    <!-- Transparent Colors -->
    <color name="transparent">#00000000</color>
    <color name="transparent_black">#80000000</color>
    <color name="transparent_white">#80FFFFFF</color>
    
    <!-- Chart Colors -->
    <color name="chart_line">#2196F3</color>
    <color name="chart_grid">#E0E0E0</color>
    <color name="chart_label">#757575</color>
    <color name="chart_highlight">#FF4081</color>

    <!-- Theme Colors -->
    <color name="primary_dark">#1565C0</color>
    <color name="primary_darker">#0D47A1</color>
    <color name="secondary_dark">#F50057</color>
    <color name="secondary_darker">#C51162</color>
    
    <!-- Material Theme Colors -->
    <color name="primary">@color/purple_500</color>
    <color name="primary_variant">@color/purple_700</color>
    <color name="on_primary">@color/white</color>
    <color name="secondary">@color/teal_200</color>
    <color name="secondary_variant">@color/teal_700</color>
    <color name="on_secondary">@color/black</color>
    <color name="on_background">@color/black</color>
    <color name="on_surface">@color/black</color>
</resources> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\values\dimens.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Margins -->
    <dimen name="margin_tiny">2dp</dimen>
    <dimen name="margin_small">8dp</dimen>
    <dimen name="margin_medium">16dp</dimen>
    <dimen name="margin_large">24dp</dimen>
    <dimen name="margin_xlarge">32dp</dimen>
    <dimen name="margin_xxlarge">32dp</dimen>
    
    <!-- Padding -->
    <dimen name="padding_small">8dp</dimen>
    <dimen name="padding_medium">16dp</dimen>
    <dimen name="padding_large">24dp</dimen>
    <dimen name="padding_xlarge">24dp</dimen>
    
    <!-- Text Sizes -->
    <dimen name="text_caption">12sp</dimen>
    <dimen name="text_body2">14sp</dimen>
    <dimen name="text_body1">16sp</dimen>
    <dimen name="text_title">20sp</dimen>
    <dimen name="text_headline">24sp</dimen>
    
    <!-- Component Sizes -->
    <dimen name="toolbar_height">56dp</dimen>
    <dimen name="bottom_nav_height">56dp</dimen>
    <dimen name="fab_margin">16dp</dimen>
    <dimen name="card_corner_radius">8dp</dimen>
    <dimen name="card_elevation">4dp</dimen>
    <dimen name="divider_height">1dp</dimen>
    
    <!-- Chart Dimensions -->
    <dimen name="chart_height">200dp</dimen>
    <dimen name="chart_line_width">2dp</dimen>
    <dimen name="chart_point_radius">4dp</dimen>
    <dimen name="chart_label_padding">4dp</dimen>
    
    <!-- Custom Dimensions -->
    <dimen name="tracking_preview_min_height">240dp</dimen>
    <dimen name="tracking_controls_height">56dp</dimen>
    <dimen name="stats_card_min_height">120dp</dimen>
</resources> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\values\strings.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">Roulette Tracker</string>
    
    <!-- Navigation Titles -->
    <string name="tracking">Tracking</string>
    <string name="stats">Statistiken</string>
    <string name="settings">Einstellungen</string>
    
    <!-- Navigation & UI -->
    <string name="start_tracking">Tracking starten</string>
    <string name="stop_tracking">Tracking stoppen</string>
    <string name="tracking_status">Tracking Status</string>
    <string name="enter_number">Nummer eingeben</string>
    
    <!-- Tracking Status Messages -->
    <string name="status_initializing">Initialisiere...</string>
    <string name="status_running">Tracking lÃ¤uft</string>
    <string name="status_error">Fehler: %1$s</string>
    <string name="status_ball_lost">Ball nicht gefunden</string>
    <string name="status_wheel_lost">Rad nicht gefunden</string>
    <string name="status_predicting">Vorhersage in %1$d Sekunden</string>
    <string name="status_prediction">Vorhergesagte Nummer: %1$d (Konfidenz: %2$.0f%%)</string>
    
    <!-- Control Panel -->
    <string name="toggle_video">Gespeichertes Video</string>
    <string name="toggle_stream">WiFi Stream</string>
    
    <!-- Error Messages -->
    <string name="error_camera_init">Kamera konnte nicht initialisiert werden</string>
    <string name="error_opencv_init">OpenCV konnte nicht initialisiert werden</string>
    <string name="error_permissions">Berechtigungen nicht erteilt. Die App kann nicht korrekt funktionieren.</string>
    <string name="error_permissions_required">BenÃ¶tigte Berechtigungen wurden nicht erteilt</string>
    
    <!-- Settings -->
    <string name="quality_settings">QualitÃ¤tseinstellungen</string>
    <string name="high_quality_mode">Hohe QualitÃ¤t</string>
    <string name="detection_settings">Erkennungseinstellungen</string>
    <string name="enable_roi">ROI aktivieren</string>
    <string name="other_settings">Sonstige Einstellungen</string>
    <string name="auto_save">Automatisch speichern</string>
    <string name="debug_mode">Debug-Modus</string>
    <string name="voice_enabled">Sprachausgabe</string>
    
    <!-- Stats -->
    <string name="total_predictions">Gesamte Vorhersagen: %d</string>
    <string name="successful_predictions">Erfolgreiche Vorhersagen: %d</string>
    <string name="success_rate">Erfolgsrate: %.1f%%</string>
    <string name="average_confidence">Durchschnittliche Konfidenz: %d%%</string>
    <string name="average_time_to_landing">Durchschnittliche Zeit bis zur Landung: %.1fs</string>
    <string name="trend">Trend: %s</string>
    <string name="chart_confidence">Konfidenz</string>
    <string name="chart_time_to_landing">Zeit bis zur Landung</string>
    
    <!-- Time Ranges -->
    <string name="last_hour">Letzte Stunde</string>
    <string name="today">Heute</string>
    <string name="last_week">Letzte Woche</string>
    <string name="all_time">Alle</string>
    
    <!-- Settings Labels -->
    <string name="label_confidence">Konfidenz-Schwelle: %.0f%%</string>
    <string name="label_prediction_delay">Vorhersage-VerzÃ¶gerung: %d Sekunden</string>
    
    <!-- Permission Strings -->
    <string name="permissions_required">Berechtigungen erforderlich</string>
    <string name="permissions_explanation">Die App benÃ¶tigt Zugriff auf die Kamera und den Speicher, um das Roulette-Rad zu erkennen und Zahlen zu analysieren.</string>
    <string name="grant_permissions">Berechtigungen gewÃ¤hren</string>
    <string name="deny_permissions">Ablehnen</string>
    <string name="ok">OK</string>
    <string name="cancel">Abbrechen</string>
    <string name="permissions_required_error">Die App benÃ¶tigt diese Berechtigungen zum Funktionieren.</string>
</resources> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\values\styles.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <style name="TrackingStatusText">
        <item name="android:textColor">@color/white</item>
        <item name="android:textSize">16sp</item>
        <item name="android:gravity">center</item>
        <item name="android:padding">8dp</item>
    </style>

    <style name="TrackingStatusProgress" parent="Widget.AppCompat.ProgressBar.Horizontal">
        <item name="android:progressTint">@color/status_success</item>
        <item name="android:progressBackgroundTint">@color/transparent_black</item>
    </style>

    <!-- Chart Styles -->
    <style name="ChartStyle">
        <item name="android:layout_width">match_parent</item>
        <item name="android:layout_height">200dp</item>
        <item name="android:layout_marginTop">16dp</item>
        <item name="android:padding">8dp</item>
    </style>
    
    <style name="ChartTitle">
        <item name="android:layout_width">wrap_content</item>
        <item name="android:layout_height">wrap_content</item>
        <item name="android:textAppearance">?attr/textAppearanceHeadline2</item>
        <item name="android:layout_marginBottom">8dp</item>
    </style>
    
    <!-- Card Styles -->
    <style name="CardStyle">
        <item name="android:layout_width">match_parent</item>
        <item name="android:layout_height">wrap_content</item>
        <item name="android:layout_marginBottom">@dimen/margin_medium</item>
        <item name="cardCornerRadius">@dimen/card_corner_radius</item>
        <item name="cardElevation">@dimen/card_elevation</item>
        <item name="contentPadding">@dimen/padding_large</item>
    </style>
    
    <style name="CardContent">
        <item name="android:layout_width">match_parent</item>
        <item name="android:layout_height">wrap_content</item>
        <item name="android:orientation">vertical</item>
        <item name="android:padding">@dimen/padding_medium</item>
    </style>
    
    <!-- Button Styles -->
    <style name="PrimaryButton" parent="Widget.MaterialComponents.Button">
        <item name="android:layout_width">match_parent</item>
        <item name="android:layout_height">wrap_content</item>
        <item name="android:textAllCaps">false</item>
        <item name="android:padding">12dp</item>
    </style>
    
    <style name="SecondaryButton" parent="Widget.MaterialComponents.Button.OutlinedButton">
        <item name="android:layout_width">match_parent</item>
        <item name="android:layout_height">wrap_content</item>
        <item name="android:textAllCaps">false</item>
        <item name="android:padding">12dp</item>
    </style>
    
    <!-- Text Styles -->
    <style name="SectionTitle" parent="TextAppearance.MaterialComponents.Headline6">
        <item name="android:layout_marginBottom">@dimen/margin_medium</item>
        <item name="android:textColor">?attr/colorPrimary</item>
    </style>

    <style name="SettingLabel" parent="TextAppearance.MaterialComponents.Body1">
        <item name="android:layout_marginTop">@dimen/margin_small</item>
        <item name="android:layout_marginBottom">@dimen/margin_small</item>
    </style>

    <!-- Switch Styles -->
    <style name="SettingsSwitch" parent="Widget.MaterialComponents.CompoundButton.Switch">
        <item name="android:layout_width">match_parent</item>
        <item name="android:layout_height">wrap_content</item>
        <item name="android:layout_marginTop">@dimen/margin_small</item>
        <item name="android:layout_marginBottom">@dimen/margin_small</item>
        <item name="android:textAppearance">@style/SettingLabel</item>
    </style>
    
    <!-- Slider Styles -->
    <style name="SettingsSlider" parent="Widget.MaterialComponents.Slider">
        <item name="android:layout_width">match_parent</item>
        <item name="android:layout_height">wrap_content</item>
        <item name="android:layout_marginTop">@dimen/margin_small</item>
        <item name="android:layout_marginBottom">@dimen/margin_medium</item>
        <item name="tickVisible">true</item>
        <item name="labelBehavior">floating</item>
        <item name="trackColorActive">?attr/colorPrimary</item>
        <item name="trackColorInactive">?attr/colorPrimaryVariant</item>
        <item name="thumbColor">?attr/colorPrimary</item>
        <item name="haloColor">?attr/colorPrimaryVariant</item>
    </style>

    <!-- Component Styles -->
    <style name="Widget.RouletteTracker.BottomNavigationView" parent="Widget.MaterialComponents.BottomNavigationView">
        <item name="android:background">?attr/colorSurface</item>
        <item name="itemIconTint">@color/primary</item>
        <item name="itemTextColor">@color/primary</item>
    </style>

    <style name="Widget.RouletteTracker.Toolbar" parent="Widget.MaterialComponents.Toolbar.Primary">
        <item name="android:background">?attr/colorPrimary</item>
        <item name="android:theme">@style/ThemeOverlay.MaterialComponents.Dark.ActionBar</item>
        <item name="popupTheme">@style/ThemeOverlay.MaterialComponents.Light</item>
    </style>

    <style name="ThemeOverlay.RouletteTracker.BottomNavigation" parent="">
        <item name="colorPrimary">?attr/colorSecondary</item>
        <item name="colorOnPrimary">?attr/colorOnSecondary</item>
    </style>

    <style name="ThemeOverlay.RouletteTracker.Toolbar" parent="">
        <item name="colorControlNormal">?attr/colorOnPrimary</item>
    </style>
</resources> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\values\themes.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Base application theme -->
    <style name="Theme.RouletteTracker" parent="Theme.Material3.DayNight">
        <!-- Primary brand color. -->
        <item name="colorPrimary">@color/primary</item>
        <item name="colorPrimaryVariant">@color/primary_variant</item>
        <item name="colorOnPrimary">@color/white</item>
        <!-- Secondary brand color. -->
        <item name="colorSecondary">@color/secondary</item>
        <item name="colorSecondaryVariant">@color/secondary_variant</item>
        <item name="colorOnSecondary">@color/black</item>
        <!-- Status bar color. -->
        <item name="android:statusBarColor">?attr/colorPrimaryVariant</item>
        
        <!-- Komponenten-Themes -->
        <item name="bottomNavigationStyle">@style/Widget.RouletteTracker.BottomNavigationView</item>
        <item name="toolbarStyle">@style/Widget.RouletteTracker.Toolbar</item>
    </style>
</resources> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\values\type.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <style name="TextAppearance.RouletteTracker.Headline1" parent="TextAppearance.MaterialComponents.Headline1">
        <item name="android:textSize">@dimen/text_headline</item>
        <item name="android:textColor">?attr/colorOnSurface</item>
    </style>
    
    <style name="TextAppearance.RouletteTracker.Headline2" parent="TextAppearance.MaterialComponents.Headline2">
        <item name="android:textSize">@dimen/text_title</item>
        <item name="android:textColor">?attr/colorOnSurface</item>
    </style>
    
    <style name="TextAppearance.RouletteTracker.Body1" parent="TextAppearance.MaterialComponents.Body1">
        <item name="android:textSize">@dimen/text_body1</item>
        <item name="android:textColor">?attr/colorOnSurface</item>
    </style>
    
    <style name="TextAppearance.RouletteTracker.Body2" parent="TextAppearance.MaterialComponents.Body2">
        <item name="android:textSize">@dimen/text_body2</item>
        <item name="android:textColor">?attr/colorOnSurface</item>
    </style>
</resources> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\values-night\colors.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Background colors for dark theme -->
    <color name="background_dark">#121212</color>
    <color name="surface_dark">#1E1E1E</color>
    
    <!-- Semantic colors for dark theme -->
    <color name="error_dark">#CF6679</color>
    
    <!-- Chart colors for dark theme -->
    <color name="chart_line_dark">#64B5F6</color>
    <color name="chart_bar_dark">#81C784</color>
    <color name="chart_grid_dark">#424242</color>
</resources> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\values-night\themes.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <style name="Theme.RouletteTracker" parent="Theme.MaterialComponents.DayNight.NoActionBar">
        <!-- Primary brand color. -->
        <item name="colorPrimary">@color/primary_dark</item>
        <item name="colorPrimaryVariant">@color/primary_darker</item>
        <item name="colorOnPrimary">@color/white</item>
        
        <!-- Secondary brand color. -->
        <item name="colorSecondary">@color/secondary_dark</item>
        <item name="colorSecondaryVariant">@color/secondary_darker</item>
        <item name="colorOnSecondary">@color/white</item>
        
        <!-- Background colors -->
        <item name="android:colorBackground">@color/background_dark</item>
        <item name="colorSurface">@color/surface_dark</item>
        <item name="colorError">@color/error_dark</item>
        
        <!-- Status bar color. -->
        <item name="android:statusBarColor">@android:color/transparent</item>
        <item name="android:windowLightStatusBar">false</item>
    </style>
</resources> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\xml\backup_rules.xml
==========================================

<?xml version="1.0" encoding="utf-8"?><!--
   Sample backup rules file; uncomment and customize as necessary.
   See https://developer.android.com/guide/topics/data/autobackup
   for details.
   Note: This file is ignored for devices older that API 31
   See https://developer.android.com/about/versions/12/backup-restore
-->
<full-backup-content>
    <!-- App-Einstellungen -->
    <include domain="sharedpref" path="roulette_tracker_settings.xml"/>
    
    <!-- Datenbank-Backup -->
    <include domain="database" path="roulette_database"/>
    
    <!-- Simulationsergebnisse und Statistiken -->
    <include domain="database" path="simulations"/>
    <include domain="database" path="simulation_results"/>
    
    <!-- Debug-Daten ausschlieÃŸen -->
    <exclude domain="sharedpref" path="debug_settings"/>
    
    <!-- TemporÃ¤re Tracking-Daten ausschlieÃŸen -->
    <exclude domain="file" path="temp"/>
    <exclude domain="file" path="cache"/>
    <exclude domain="file" path="camera_calibration"/>
    
    <!-- GerÃ¤tespezifische Konfigurationen ausschlieÃŸen -->
    <exclude domain="sharedpref" path="device_config.xml"/>
</full-backup-content>

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\xml\data_extraction_rules.xml
==========================================

<?xml version="1.0" encoding="utf-8"?><!--
   Sample data extraction rules file; uncomment and customize as necessary.
   See https://developer.android.com/about/versions/12/backup-restore#xml-changes
   for details.
-->
<data-extraction-rules>
    <cloud-backup>
        <!-- Sichern der wichtigen App-Daten -->
        <include domain="database" path="." />
        <include domain="sharedpref" path="." />
        <include domain="file" path="tracking_data" />
        <include domain="file" path="statistics" />
        
        <!-- AusschlieÃŸen von temporÃ¤ren und Cache-Dateien -->
        <exclude domain="file" path="cache/" />
        <exclude domain="file" path="temp/" />
        <exclude domain="file" path="logs/" />
        <exclude domain="file" path="frames/" />
    </cloud-backup>
    
    <device-transfer>
        <!-- Gleiche Regeln fÃ¼r GerÃ¤teÃ¼bertragung -->
        <include domain="database" path="." />
        <include domain="sharedpref" path="." />
        <include domain="file" path="tracking_data" />
        <include domain="file" path="statistics" />
        
        <exclude domain="file" path="cache/" />
        <exclude domain="file" path="temp/" />
        <exclude domain="file" path="logs/" />
        <exclude domain="file" path="frames/" />
    </device-transfer>
</data-extraction-rules>

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\main\res\xml\file_paths.xml
==========================================

<?xml version="1.0" encoding="utf-8"?>
<paths>
    <files-path
        name="videos"
        path="videos/" />
    <cache-path
        name="cache"
        path="." />
    <external-files-path
        name="external_files"
        path="." />
</paths> 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\app\src\test\java\com\roulette\tracker\ExampleUnitTest.kt
==========================================

package com.roulette.tracker

import org.junit.Test

import org.junit.Assert.*

/**
 * Example local unit test, which will execute on the development machine (host).
 *
 * See [testing documentation](http://d.android.com/tools/testing).
 */
class ExampleUnitTest {
    @Test
    fun addition_isCorrect() {
        assertEquals(4, 2 + 2)
    }
}

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\opencv-wrapper\src\main\java\com\roulette\tracker\opencv\ImageProcessingService.kt
==========================================

package com.roulette.tracker.opencv

import org.opencv.core.*
import org.opencv.imgproc.Imgproc
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class ImageProcessingService @Inject constructor() {
    
    fun preprocessImage(frame: Mat, config: ProcessingConfig): Mat {
        var result = frame.clone()
        
        try {
            if (config.resize != null) {
                result = OpenCVUtils.resizeImage(result, config.resize)
            }
            
            if (config.grayscale) {
                result = OpenCVUtils.toGrayscale(result)
            }
            
            if (config.blur != null) {
                result = OpenCVUtils.blur(result, config.blur)
            }
            
            if (config.threshold) {
                result = OpenCVUtils.threshold(result)
            }

            if (config.detectContours) {
                val contours = OpenCVUtils.findContours(result)
                if (config.drawContours) {
                    OpenCVUtils.drawContours(result, contours)
                }
            }

            if (config.detectCircles) {
                val circles = OpenCVUtils.detectCircles(
                    result,
                    config.minCircleRadius ?: 10.0,
                    config.maxCircleRadius ?: 100.0
                )
                // Kreise zeichnen
                if (!circles.empty() && config.drawCircles) {
                    for (i in 0 until circles.cols()) {
                        val circle = circles.get(0, i)
                        val center = Point(circle[0], circle[1])
                        val radius = circle[2].toInt()
                        Imgproc.circle(result, center, radius, Scalar(0.0, 255.0, 0.0), 2)
                    }
                }
                circles.release()
            }
            
            return result
        } catch (e: Exception) {
            result.release()
            throw e
        }
    }
    
    data class ProcessingConfig(
        val resize: Size? = null,
        val grayscale: Boolean = false,
        val blur: Size? = null,
        val threshold: Boolean = false,
        val detectContours: Boolean = false,
        val drawContours: Boolean = false,
        val detectCircles: Boolean = false,
        val drawCircles: Boolean = false,
        val minCircleRadius: Double? = null,
        val maxCircleRadius: Double? = null
    )

    companion object {
        private const val TAG = "ImageProcessingService"
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\opencv-wrapper\src\main\java\com\roulette\tracker\opencv\OpenCVException.kt
==========================================

package com.roulette.tracker.opencv

sealed class OpenCVException(message: String, cause: Throwable? = null) : Exception(message, cause) {
    class InitializationError(message: String, cause: Throwable? = null) : 
        OpenCVException("OpenCV initialization failed: $message", cause)
    
    class ProcessingError(message: String, cause: Throwable? = null) : 
        OpenCVException("Image processing failed: $message", cause)
    
    class ResourceError(message: String, cause: Throwable? = null) : 
        OpenCVException("OpenCV resource error: $message", cause)
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\opencv-wrapper\src\main\java\com\roulette\tracker\opencv\OpenCVInitializer.kt
==========================================

package com.roulette.tracker.opencv

import android.content.Context
import android.util.Log
import com.roulette.tracker.opencv.engine.OpenCVEngineManager
import com.roulette.tracker.opencv.installation.OpenCVInstallationManager
import org.opencv.android.LoaderCallbackInterface
import org.opencv.android.OpenCVLoader
import org.opencv.core.Core
import kotlin.coroutines.resume
import kotlin.coroutines.resumeWithException
import kotlin.coroutines.suspendCoroutine

class OpenCVInitializer(
    private val installationManager: OpenCVInstallationManager
) {
    private var engineManager: OpenCVEngineManager? = null
    
    suspend fun initializeOpenCV(context: Context): Boolean {
        return try {
            // Erst sicherstellen, dass OpenCV installiert ist
            if (!installationManager.ensureOpenCVInstalled(REQUIRED_VERSION)) {
                throw OpenCVException.InitializationError("Failed to ensure OpenCV installation")
            }

            // Dann die native Bibliothek initialisieren
            initializeNativeLibrary(context)
        } catch (e: Exception) {
            Log.e(TAG, "Error initializing OpenCV: ${e.message}")
            false
        }
    }
    
    private suspend fun initializeNativeLibrary(context: Context): Boolean = 
        suspendCoroutine { continuation ->
            try {
                if (!OpenCVLoader.initAsync(REQUIRED_VERSION, context, object : LoaderCallbackInterface {
                    override fun onManagerConnected(status: Int) {
                        when (status) {
                            LoaderCallbackInterface.SUCCESS -> {
                                logOpenCVBuildInfo()
                                continuation.resume(true)
                            }
                            LoaderCallbackInterface.INIT_FAILED -> {
                                val error = OpenCVException.InitializationError("Manager initialization failed")
                                continuation.resumeWithException(error)
                            }
                            LoaderCallbackInterface.INSTALL_CANCELED -> {
                                val error = OpenCVException.InitializationError("Installation cancelled by user")
                                continuation.resumeWithException(error)
                            }
                            LoaderCallbackInterface.MARKET_ERROR -> {
                                val error = OpenCVException.InitializationError("Google Play Market error")
                                continuation.resumeWithException(error)
                            }
                            LoaderCallbackInterface.INCOMPATIBLE_MANAGER_VERSION -> {
                                val error = OpenCVException.InitializationError("Incompatible OpenCV Manager version")
                                continuation.resumeWithException(error)
                            }
                            else -> {
                                val error = OpenCVException.InitializationError("Unknown error: $status")
                                continuation.resumeWithException(error)
                            }
                        }
                    }

                    override fun onPackageInstall(operation: Int, callback: LoaderCallbackInterface?) {
                        Log.d(TAG, "OpenCV package installation requested: $operation")
                        when (operation) {
                            InstallCallbackInterface.NEW_INSTALLATION -> {
                                Log.d(TAG, "New installation required")
                                installationManager.ensureOpenCVInstalled(REQUIRED_VERSION)
                            }
                            InstallCallbackInterface.INSTALLATION_PROGRESS -> {
                                Log.d(TAG, "Installation in progress")
                            }
                        }
                        callback?.onManagerConnected(LoaderCallbackInterface.SUCCESS)
                    }
                })) {
                    continuation.resumeWithException(
                        OpenCVException.InitializationError("Failed to start async initialization")
                    )
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error initializing OpenCV: ${e.message}")
                continuation.resumeWithException(
                    OpenCVException.InitializationError("Unexpected error", e)
                )
            }
        }

    private fun logOpenCVBuildInfo() {
        val buildInfo = Core.getBuildInformation()
        Log.i(TAG, "OpenCV Build Information:")
        buildInfo.split(System.lineSeparator()).forEach { 
            Log.i(TAG, it)
        }
    }

    fun cleanup() {
        engineManager?.unbindService()
        engineManager = null
    }

    companion object {
        private const val TAG = "OpenCVInitializer"
        private const val REQUIRED_VERSION = "4.11.0"
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\opencv-wrapper\src\main\java\com\roulette\tracker\opencv\OpenCVUtils.kt
==========================================

package com.roulette.tracker.opencv

import org.opencv.core.*
import org.opencv.imgproc.Imgproc

object OpenCVUtils {
    
    fun resizeImage(source: Mat, targetSize: Size): Mat {
        val result = Mat()
        Imgproc.resize(source, result, targetSize)
        return result
    }
    
    fun toGrayscale(source: Mat): Mat {
        val result = Mat()
        Imgproc.cvtColor(source, result, Imgproc.COLOR_BGR2GRAY)
        return result
    }
    
    fun blur(source: Mat, kernelSize: Size): Mat {
        val result = Mat()
        Imgproc.GaussianBlur(source, result, kernelSize, 0.0)
        return result
    }
    
    fun threshold(source: Mat, thresh: Double = 127.0, maxval: Double = 255.0): Mat {
        val result = Mat()
        Imgproc.threshold(source, result, thresh, maxval, Imgproc.THRESH_BINARY)
        return result
    }

    // Neue Funktionen
    fun findContours(source: Mat): List<MatOfPoint> {
        val contours = mutableListOf<MatOfPoint>()
        val hierarchy = Mat()
        Imgproc.findContours(
            source,
            contours,
            hierarchy,
            Imgproc.RETR_EXTERNAL,
            Imgproc.CHAIN_APPROX_SIMPLE
        )
        return contours
    }

    fun drawContours(image: Mat, contours: List<MatOfPoint>, color: Scalar = Scalar(0.0, 255.0, 0.0)) {
        Imgproc.drawContours(image, contours, -1, color, 2)
    }

    fun detectCircles(source: Mat, minRadius: Double = 10.0, maxRadius: Double = 100.0): Mat {
        val circles = Mat()
        Imgproc.HoughCircles(
            source,
            circles,
            Imgproc.HOUGH_GRADIENT,
            1.0,
            20.0,
            100.0,
            30.0,
            minRadius.toInt(),
            maxRadius.toInt()
        )
        return circles
    }

    fun release(vararg mats: Mat?) {
        mats.forEach { it?.release() }
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\opencv-wrapper\src\main\java\com\roulette\tracker\opencv\di\OpenCVModule.kt
==========================================

package com.roulette.tracker.opencv.di

import android.content.Context
import com.roulette.tracker.opencv.ImageProcessingService
import com.roulette.tracker.opencv.OpenCVInitializer
import com.roulette.tracker.opencv.engine.OpenCVEngineManager
import com.roulette.tracker.opencv.installation.OpenCVInstallationManager
import com.roulette.tracker.opencv.version.OpenCVVersionManager
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object OpenCVModule {
    
    @Provides
    @Singleton
    fun provideOpenCVInitializer(
        installationManager: OpenCVInstallationManager
    ): OpenCVInitializer {
        return OpenCVInitializer(installationManager)
    }
    
    @Provides
    @Singleton
    fun provideImageProcessingService(): ImageProcessingService {
        return ImageProcessingService()
    }

    @Provides
    @Singleton
    fun provideOpenCVEngineManager(
        @ApplicationContext context: Context
    ): OpenCVEngineManager {
        return OpenCVEngineManager(context)
    }

    @Provides
    @Singleton
    fun provideOpenCVVersionManager(
        @ApplicationContext context: Context
    ): OpenCVVersionManager {
        return OpenCVVersionManager(context)
    }

    @Provides
    @Singleton
    fun provideOpenCVInstallationManager(
        @ApplicationContext context: Context,
        versionManager: OpenCVVersionManager,
        engineManager: OpenCVEngineManager
    ): OpenCVInstallationManager {
        return OpenCVInstallationManager(context, versionManager, engineManager)
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\opencv-wrapper\src\main\java\com\roulette\tracker\opencv\engine\OpenCVEngineManager.kt
==========================================

package com.roulette.tracker.opencv.engine

import android.content.ComponentName
import android.content.Context
import android.content.Intent
import android.content.ServiceConnection
import android.os.IBinder
import android.util.Log
import com.roulette.tracker.opencv.OpenCVException
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import org.opencv.engine.OpenCVEngineInterface
import kotlin.coroutines.resume
import kotlin.coroutines.resumeWithException
import kotlin.coroutines.suspendCoroutine

class OpenCVEngineManager(private val context: Context) {
    private var engineInterface: OpenCVEngineInterface? = null
    
    private val _connectionState = MutableStateFlow<ConnectionState>(ConnectionState.Disconnected)
    val connectionState: StateFlow<ConnectionState> = _connectionState.asStateFlow()
    
    private val serviceConnection = object : ServiceConnection {
        override fun onServiceConnected(name: ComponentName?, service: IBinder?) {
            try {
                engineInterface = OpenCVEngineInterface.Stub.asInterface(service)
                _connectionState.value = ConnectionState.Connected
                Log.d(TAG, "OpenCV Engine Service connected")
            } catch (e: Exception) {
                _connectionState.value = ConnectionState.Error(e)
                Log.e(TAG, "Error connecting to OpenCV Engine Service: ${e.message}")
            }
        }

        override fun onServiceDisconnected(name: ComponentName?) {
            engineInterface = null
            _connectionState.value = ConnectionState.Disconnected
            Log.d(TAG, "OpenCV Engine Service disconnected")
        }
    }

    suspend fun bindService(): Boolean = suspendCoroutine { continuation ->
        try {
            _connectionState.value = ConnectionState.Connecting
            val intent = Intent("org.opencv.engine.BIND")
            intent.setPackage("org.opencv.engine")
            
            val success = context.bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE)
            if (!success) {
                _connectionState.value = ConnectionState.Error(
                    OpenCVException.InitializationError("Failed to bind service")
                )
            }
            continuation.resume(success)
        } catch (e: Exception) {
            _connectionState.value = ConnectionState.Error(e)
            Log.e(TAG, "Error binding to OpenCV Engine Service: ${e.message}")
            continuation.resume(false)
        }
    }

    fun unbindService() {
        if (_connectionState.value is ConnectionState.Connected) {
            try {
                context.unbindService(serviceConnection)
                _connectionState.value = ConnectionState.Disconnected
            } catch (e: Exception) {
                _connectionState.value = ConnectionState.Error(e)
                Log.e(TAG, "Error unbinding from OpenCV Engine Service: ${e.message}")
            }
        }
    }

    suspend fun getEngineVersion(): Int = suspendCoroutine { continuation ->
        try {
            val version = engineInterface?.engineVersion
            if (version != null) {
                continuation.resume(version)
            } else {
                continuation.resumeWithException(
                    OpenCVException.InitializationError("Could not get engine version")
                )
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error getting engine version: ${e.message}")
            continuation.resumeWithException(e)
        }
    }

    suspend fun getLibPathByVersion(version: String): String = suspendCoroutine { continuation ->
        try {
            val path = engineInterface?.getLibPathByVersion(version)
            if (!path.isNullOrEmpty()) {
                continuation.resume(path)
            } else {
                continuation.resumeWithException(
                    OpenCVException.InitializationError("Library path not found for version $version")
                )
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error getting lib path: ${e.message}")
            continuation.resumeWithException(e)
        }
    }

    suspend fun installVersion(version: String): Boolean = suspendCoroutine { continuation ->
        try {
            val success = engineInterface?.installVersion(version) ?: false
            continuation.resume(success)
        } catch (e: Exception) {
            Log.e(TAG, "Error installing OpenCV version $version: ${e.message}")
            continuation.resumeWithException(e)
        }
    }

    suspend fun getLibraryList(version: String): List<String> = suspendCoroutine { continuation ->
        try {
            val libraryList = engineInterface?.getLibraryList(version)
            if (!libraryList.isNullOrEmpty()) {
                continuation.resume(libraryList.split(";"))
            } else {
                continuation.resumeWithException(
                    OpenCVException.InitializationError("No libraries found for version $version")
                )
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error getting library list: ${e.message}")
            continuation.resumeWithException(e)
        }
    }

    sealed class ConnectionState {
        object Disconnected : ConnectionState()
        object Connecting : ConnectionState()
        object Connected : ConnectionState()
        data class Error(val error: Throwable) : ConnectionState()
    }

    companion object {
        private const val TAG = "OpenCVEngineManager"
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\opencv-wrapper\src\main\java\com\roulette\tracker\opencv\installation\InstallCallbackInterface.kt
==========================================

package com.roulette.tracker.opencv.installation

interface InstallCallbackInterface {
    companion object {
        const val NEW_INSTALLATION = 0
        const val INSTALLATION_PROGRESS = 1
    }
    
    fun getPackageName(): String
    fun install()
    fun cancel()
    fun waitInstall()
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\opencv-wrapper\src\main\java\com\roulette\tracker\opencv\installation\OpenCVInstallationManager.kt
==========================================

package com.roulette.tracker.opencv.installation

import android.content.Context
import android.util.Log
import com.roulette.tracker.opencv.OpenCVException
import com.roulette.tracker.opencv.engine.OpenCVEngineManager
import com.roulette.tracker.opencv.version.OpenCVVersionManager
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class OpenCVInstallationManager @Inject constructor(
    private val context: Context,
    private val versionManager: OpenCVVersionManager,
    private val engineManager: OpenCVEngineManager
) {
    private val _installationState = MutableStateFlow<InstallationState>(InstallationState.Unknown)
    val installationState: StateFlow<InstallationState> = _installationState.asStateFlow()

    suspend fun ensureOpenCVInstalled(requiredVersion: String): Boolean {
        _installationState.value = InstallationState.Checking
        
        return try {
            when (val state = versionManager.versionState.value) {
                is OpenCVVersionManager.VersionState.NotInstalled -> {
                    _installationState.value = InstallationState.Installing
                    installOpenCV(requiredVersion)
                }
                is OpenCVVersionManager.VersionState.Incompatible -> {
                    _installationState.value = InstallationState.Updating(
                        state.installedVersion,
                        state.requiredVersion
                    )
                    updateOpenCV(requiredVersion)
                }
                is OpenCVVersionManager.VersionState.Compatible -> {
                    _installationState.value = InstallationState.Installed(state.version)
                    true
                }
                is OpenCVVersionManager.VersionState.Error -> {
                    _installationState.value = InstallationState.Error(state.error)
                    false
                }
                OpenCVVersionManager.VersionState.Unknown -> {
                    _installationState.value = InstallationState.Error(
                        OpenCVException.InitializationError("Unknown version state")
                    )
                    false
                }
            }
        } catch (e: Exception) {
            _installationState.value = InstallationState.Error(e)
            Log.e(TAG, "Error ensuring OpenCV installation: ${e.message}")
            false
        }
    }

    private suspend fun installOpenCV(version: String): Boolean {
        return try {
            val success = engineManager.installVersion(version)
            if (success) {
                _installationState.value = InstallationState.Installed(version)
            } else {
                versionManager.openPlayStore()
                _installationState.value = InstallationState.RequiresManualInstallation
            }
            success
        } catch (e: Exception) {
            _installationState.value = InstallationState.Error(e)
            Log.e(TAG, "Error installing OpenCV: ${e.message}")
            false
        }
    }

    private suspend fun updateOpenCV(version: String): Boolean {
        return try {
            val success = engineManager.installVersion(version)
            if (success) {
                _installationState.value = InstallationState.Installed(version)
            } else {
                versionManager.openPlayStore()
                _installationState.value = InstallationState.RequiresManualUpdate
            }
            success
        } catch (e: Exception) {
            _installationState.value = InstallationState.Error(e)
            Log.e(TAG, "Error updating OpenCV: ${e.message}")
            false
        }
    }

    sealed class InstallationState {
        object Unknown : InstallationState()
        object Checking : InstallationState()
        object Installing : InstallationState()
        data class Updating(val currentVersion: String, val targetVersion: String) : InstallationState()
        data class Installed(val version: String) : InstallationState()
        object RequiresManualInstallation : InstallationState()
        object RequiresManualUpdate : InstallationState()
        data class Error(val error: Throwable) : InstallationState()
    }

    companion object {
        private const val TAG = "OpenCVInstallationManager"
    }
} 

==========================================
FILE: C:\Users\user\AndroidStudioProjects\Roulette2\opencv-wrapper\src\main\java\com\roulette\tracker\opencv\version\OpenCVVersionManager.kt
==========================================

package com.roulette.tracker.opencv.version

import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.net.Uri
import android.util.Log
import com.roulette.tracker.opencv.OpenCVException
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class OpenCVVersionManager @Inject constructor(
    private val context: Context
) {
    private val _versionState = MutableStateFlow<VersionState>(VersionState.Unknown)
    val versionState: StateFlow<VersionState> = _versionState.asStateFlow()

    companion object {
        private const val TAG = "OpenCVVersionManager"
        private const val MIN_SUPPORTED_VERSION = "4.8.0"
        private const val OPENCV_PACKAGE = "org.opencv.engine"
        private const val PLAY_STORE_URL = "market://details?id=$OPENCV_PACKAGE"
        private const val PLAY_STORE_BROWSER_URL = "https://play.google.com/store/apps/details?id=$OPENCV_PACKAGE"
    }

    init {
        checkOpenCVVersion()
    }

    fun checkOpenCVVersion() {
        try {
            val installedVersion = getInstalledVersion()
            _versionState.value = when {
                installedVersion == null -> VersionState.NotInstalled
                isVersionCompatible(installedVersion) -> VersionState.Compatible(installedVersion)
                else -> VersionState.Incompatible(installedVersion, MIN_SUPPORTED_VERSION)
            }
        } catch (e: Exception) {
            _versionState.value = VersionState.Error(e)
            Log.e(TAG, "Error checking OpenCV version: ${e.message}")
        }
    }

    fun getInstalledVersion(): String? {
        return try {
            val packageInfo = context.packageManager.getPackageInfo(OPENCV_PACKAGE, 0)
            packageInfo.versionName.also {
                Log.d(TAG, "Installed OpenCV version: $it")
            }
        } catch (e: PackageManager.NameNotFoundException) {
            Log.d(TAG, "OpenCV Manager not installed")
            null
        }
    }

    fun isVersionCompatible(version: String): Boolean {
        return try {
            compareVersions(version, MIN_SUPPORTED_VERSION) >= 0
        } catch (e: Exception) {
            Log.e(TAG, "Error comparing versions: ${e.message}")
            false
        }
    }

    fun openPlayStore() {
        try {
            val intent = Intent(Intent.ACTION_VIEW).apply {
                data = Uri.parse(PLAY_STORE_URL)
                setPackage("com.android.vending")
            }
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
            
            try {
                context.startActivity(intent)
            } catch (e: Exception) {
                // Fallback zur Browser-Version wenn Play Store nicht installiert ist
                val browserIntent = Intent(Intent.ACTION_VIEW, Uri.parse(PLAY_STORE_BROWSER_URL))
                browserIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                context.startActivity(browserIntent)
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error opening Play Store: ${e.message}")
            throw OpenCVException.InitializationError("Could not open Play Store", e)
        }
    }

    private fun compareVersions(version1: String, version2: String): Int {
        val v1Parts = version1.split(".")
        val v2Parts = version2.split(".")
        
        val maxLength = maxOf(v1Parts.size, v2Parts.size)
        
        for (i in 0 until maxLength) {
            val v1 = v1Parts.getOrNull(i)?.toIntOrNull() ?: 0
            val v2 = v2Parts.getOrNull(i)?.toIntOrNull() ?: 0
            
            when {
                v1 > v2 -> return 1
                v1 < v2 -> return -1
            }
        }
        return 0
    }

    sealed class VersionState {
        object Unknown : VersionState()
        object NotInstalled : VersionState()
        data class Compatible(val version: String) : VersionState()
        data class Incompatible(val installedVersion: String, val requiredVersion: String) : VersionState()
        data class Error(val error: Throwable) : VersionState()
    }
} 
